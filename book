Как программа сохраняет свое внутреннее состояние?
Как она запоминает вещи?
Мы видели, как получать новые значения из старых значений, но это не меняет старые значения, а новые значения необходимо тут же использовать или они опять рассеются.
Чтобы поймать и задержать значения, JavaScript использует вещь, которая называется переменной (variable).

И это дает нам второй тип выражения. Специальное слово (keyword) var обозначает, что это предложение собирается определить переменную. За ним следует имя переменной и, если мы сразу хотим дать ей значение, за ним следует математический знак = и выражение.

На примере показано, как выражение создает переменную под названием caught и использует её для того, чтобы захватить число, которое станет результатом умножения 5 на 5.

После того, как переменная была определена ее имя может быть использовано, как выражение. Значение такого выражения является значением, которое в данный момент содержит переменная. Вот пример:
 var ten = 10;
console.log(ten*ten);
// > 100

Названием переменной может быть любое слово, которое не зарезервировано языком (например: var). Название не может содержать пробелы. Цифры могут входить в состав названия переменной - catch22 является приемлемым названием, например - но название не должно начинаться с цифры. Названия переменной не может включать в себя знаки препинания, кроме символов $ и _.

Когда переменная указывает на значение, это не значит, что она привязано к нему навсегда. Знак = можно применить к существующим переменным в любой момент , чтобы отсоединить их от текущего значения и сделать так, чтобы они содержали новое.

var mood = «light»;
console.log(mood);
//> light
mood = «dark»;
console.log(mood);
//> dark

Можно представлять переменные как щупальца, а не коробки. Они не содержат в себе значения; они хватают их и две переменные могут одновременно относиться к одному и тому же значению. Программа имеет доступ только к тем значениям, которые в данный момент схвачены. Когда необходимо запомнить что-то, вы отращиваете щупальцу, чтобы задержать это или прикрепляете это к существующей щупальце.

Давайте посмотрим на пример. Чтобы запомнить какое кол-во долларов Луиджи должен вам, вы создаете переменную. И, когда он отдает вам $35, вы даете этой переменной новое значение.

var luigisDebt = 140;
luigisDebt = luigidDebt - 35;
console.log(luigisDebt);
// > 105

Когда вы определяете переменную, не задавая ей значение, щупальце нечего схватить и она оканчивается воздухом. Если вы спросите значение пустой переменной, вы получите значение undefined.

Одно выражение var может определить несколько переменных. Определения должны быть разделены запятой.

var one = 1, two = 2;
console.log(one+two);
//> 3

"Ключевые и зарезервированные слова"

Слова со специальным значением, такие как var являются ключевыми (keywords) и не могут использоваться в качестве названий переменных. Также есть несколько слов, которые «зарезервированы для использования» в будущих версиях JavaScript. Они официально запрещены для использования в качестве названий для переменных, хотя некоторые окружения позволяют их использовать. Полный список ключевых и зарезервированных слов достаточно длинный.

/* break case catch class const continue debugger default delete do else enum export extends false finally for function if implements import in instances interface let new null package private protected public return static super switch this throw true try typeof var void while with yield*/

Не утруждайте себя их запоминанием, просто помните, что это может быть причиной того, что определение переменной не работает так, как вы ожидаете.

"Окружение"

Набор переменных и их значений, который существует в момент времени называется окружением. Когда программа запускается, окружение не пустует. Оно всегда содержит переменные, которые являются стандартом языка, и большую часть времени она содержит переменные, которые обеспечивают возможность взаимодействовать с окружающей системой. Например, в браузере, есть переменные и функции, которые просматривают и влияют на загруженный сайт, а также читают вводимые мышкой и клавиатурой данные.

"Функции"

Типом множества значений, которые обеспечиваются базовой средой, является функция. Функция - это часть программы, которая обернута значением. Такие значения могут быть использованы для того, чтобы запустить обернутую программу. Например, в окружении браузера, переменная alert содержит функцию, которая показывает маленькое диалоговое окно с сообщением. Оно используется так:

alert(«Good morning!»);

Исполнение функции называется её вызовом (invoking or calling), применением (applying). Вы можете вызвать функцию поставив скобки после выражения, которое производит значение функции. Обычно вы будете напрямую использовать название переменной, которая содержит функцию. Значения между скобками предоставляются программе внутри функции. На примере, функция alert использует строку текста (string), которую мы предоставляем ей в виде текста, который мы хотим отобразить в диалоговом окне. Значения, которые предоставляются функции называются параметрами (arguments). Функция alert нуждается только в одном параметре, однако другие функции могут нуждаться в другом количестве параметров и другого типа.
Функция Console.log

Функция alert может быть полезна, как инструмент вывода информации при экспериментировании, однако вас могут раздражать все эти маленькие окошки, которые приходится закрывать. В предыдущих примерах мы использовали функцию console.log для того, чтобы отображать значения. Многие системы JavaScript (включая все современные браузеры и Node.js) предоставляют возможность использовать функцию console.log, которая выписывает свои параметры в какой-либо инструмент отображающий текст. В браузерах, выводимая информация отображается в консоли JavaScript. Эта часть интерфейса браузера спрятана по умолчанию, и многие браузеры открывают ее при нажатии F12 или Cmd-Opt-I на Маке. Если это не срабатывает, поищите в меню пункт под названием «web-console» или «developer tools».

Когда вы будете воспроизводить примеры или собственный код на страницах этой книги, результаты console.log будут показаны после примера, вместо консоли браузера.

var x = 30;
console.log("the value of x is", x);
//> the value of x is 30

Несмотря на то, что названия переменных не могут содержать точку, console.log может. Потому, что console.log не простая переменная. Эта функция является выражением которое получает свойство log из значения, которое содержит переменная console. Мы выясним, что это конкретно означает в Главе 4.

"Возврат значений"

Отображение диалогового окна или написание текста на экране является побочным эффектом. Многие функции полезны своими побочными эффектами. Функции также могут производить значения, и в этом случае им не нужны побочные эффекты, чтобы быть полезными. Например, функция Math.max берет любое число из числовых значений и выдает самое большое.

console.log (Math.max(2,4));
//> 4

Когда функция производит значение, говорят, что оно возвращает (return) это значение. Всё, что производит значение в JavaScript является выражением, что означает то6 что функция может быть использоваться в более масштабных выражениях. Здесь вызов функции Math.min, которая является антонимом Math.max, используется в качестве вводных данных для сложения:

console.log(Math.min(2,4) + 100);
//> 102

Следующая глава объясняет как писать свои собственные функции.

"Запрос и подтверждение"

Окружение браузеров содержат и другие функции помимо alert для вызова диалоговых окон. Вы можете спросить у пользователя вопрос с ответом OK/Cancel с помощью функции confirm. Эта функция возвращает логическое значение: true, если пользователь выбирает OK и false, если пользователь выбирает Cancel.

confirm("Shall we, then?");

Функция prompt используется для того, чтобы задать открытый вопрос. Первый параметр это вопрос, второй - текст с которого начинает пользователь. Строка текста может быть введена в диалоговое окно и функция вернет её в виде текстовой строки.

prompt("Tell me everything you know.", "...")

Эти две функции редко используются в современном веб программировании, в основном потому, что вы никак не сможете повлиять на то, как будет выглядеть диалоговое окно, однако он полезны для игрушечных программ и экспериментов.

"Поток команд управления"

Когда ваша программа содержит более одного предложения, предложения исполняются, предсказуемо, сверху вниз. В качестве простого примера, эта программа содержит два предложения. Первое спрашивает пользователя число, а второе, которое выполняется следом, показывает квадрат этого числа.

var theNumber = Number(prompt("Pick a number",""));
alert("Your number is the square root of " + theNumber * theNumber;

Функция Number конвертирует значение в число. Нам необходима эта конвертация, так как результатом функции promt всегда выходит значение в виде текстовой строки, а нам нужно число. Есть похожие функции: String и Boolean, которые преобразуют значения в соответствующие виды.

Вот достаточно тривиальное схематичное представление прямого потока команд управления: >>>>>>>>>

"Условные операторы"

Выполнять выражения в прямой последовательности это не единственная доступная возможность. Альтернативой является условные операторы, когда мы выбираем два различных сценария, основываясь на логическом значении.

Условные операторы начинаются с ключевого слова if в JavaScript. Проще говоря, мы хотим, чтобы исполнялся какой-то код, в случае и только в случае, если конкретное условие соблюдается. Например, в предыдущей программе, мы хотели бы показать квадрат вводимой информации, только если вводимая информация является числом.

var theNumber = Number(prompt("Pick a number", ""));
if (!isNaN(theNumber))
alert("Your number is the square root of " + theNumber * theNumber);

В этой модификации, если мы введем "cheese", мы не увидим никакого результата.

Ключевое слово if выполняет или пропускает предложение в зависимости от значения логического выражения. Определяющее выражение пишется после ключевого слова в скобках после исполняемого предложения.

Функция isNaN стандартная функция JavaScript, которая возвращает true только если параметр, который задается не является числом. Функция Number возвращает NaN, когда вы задаете в качеств параметра текстовую строку, которая не представляет собой действующее число. Таким образом, это условие можно перевести следующим образом: "до тех пор пока theNumber не является числом, делай это".

Часто вам нужно будет писать код, который выполняется, когда условие содержит значение true, а также код, который выполняется при противоположном значении. Этот альтернативный сценарий изображается в виде второй стрелки на диаграме. Ключевое слово "else" можно использовать вместе с if, чтобы создать два отдельных сценария с альтернативным исполнением.

var theNumber = Number(prompt ("Pick a number",""));
if (!isNaN(theNumber))
     alert ("Your number is the square root of " + theNumber * theNumber);
else
    alert ("Hey. Why didn't you give me a number?");

Если у нас более двух сценариев для выбора, можно связать между собой несколько пар if/else выражений. Вот пример:

var num = Number(prompt ("Pick a number","0"));
if (num < 10)
    alert("Small");
else if (num < 100)
     alert("Medium");
else
    alert("Large");

Программа сначала проверит не является ли число меньше 10. Если оно меньше 10, то выберет ветку, которая покажет "Small", и завершится. Если нет, она пройдет по ветке else, которая содержит второе условие if. Если второе условие (<100) выполняется, что значит число находится между 10 и 100, то показывается сообщение "Medium". Если и оно не выполняется, то выбирается вторая и последняя ветка.

Поток команд такой программы выглядит так:

"Операторы цикла while и do"

Рассмотрите программу, которая печатает все четные числа от 0 до 12. Один способ написать её выглядит так:

console.log(0);
console.log(2);
console.log(4);
console.log(6);
console.log(8);
console.log(10);
console.log(12);

Это сработает, но идея написания программы заключается в том, чтобы работы было меньше, а не больше. Если бы нам потребовалось вывести все четные числа меньше 1000, выше указанный пример был бы неприемлем. Нам нужно, чтобы код повторялся. Эта форма потока команд управления называется оператором цикла:

var number = 0;
while (number <=12) {
console.log(number);
number = number + 2;
}
// > 0
// > 2
// > ... etc.

Выражение, которое начинается с ключевого слова while создает оператор цикла. За словом while идет предложение в скобках, которое похоже на условный оператор if. Цикличный оператор выполняет предлажение до тех пор пока выражение производит значение, которое при переводе в логическое значение преобразуется в true.

В этом операторе цикла мы хотим распечатать текущий номер и добавить два к нашей переменной. Когда бы нам не понадобилось выполнить несколько предложений внутри оператора цикла, мы оборачиваем их в фигурные скобки ({и}). Скобки делают с предложениями то же, что и обычные скобки делают с выражениями: они группируют их, позволяя считать их как отдельное предложение. Последовательность предложений заключенных в скобки называют блоком.

Многие JavaScript программисты обхватывают каждый циклический оператор или if оператор в скобки. Они делают так, чтобы соблюсти целостность и избежать в будущем добавления или удаления скобок при изменении количества предложений в теле программы. В этой книге, большинство программ с одним единственным предложением будет написано без скобок, так как автор ценит краткость. Вы можете свободно ползоваться любым из описанных способов.

Переменная number показывает то, как переменные могут отследить прогресс программы. Каждый раз, когда оператор цикла повторяется, переменная number увеличивается на 2. Затем, при каждом повторении оно сравнивается с числом 12, чтобы определить всю ли задуманную работу выполнила программа.

В качестве примера, который выполняет что-то полезное, мы можем написать программу которая вычисляет и показывает 2 в степени 10. Для этого мы будем использовать две переменные: одна будет следить за результатом, а другая считать как часто мы умножили число на 2. Оператор цикла проверяет достигла ли вторая переменная 10 и потом обновляет обе переменные.

var result = 1;
var counter = 0;
while (counter < 10) {
    result = result * 2;
    counter = counter + 1;
}
console.log(result);
// > 1024

Счётчик также может начать проверять условие <=10, начиная с 1, но по причие, описанной в главе 4, лучшей привыкать начинать счетчик с 0.

Оператор цикла do имеет схожую структуру контроля с оператором цикла while. Отличие лишь в одном: оператор цикла do исполняет тело своей программы как минимум 1 раз и начинает проверять не нужно ли остановиться сразу после первого исполнения. Чтобы отразить это, проверка появляется после тела оператора цикла:

do {
    var yourName = prompt ("Who are you?");
} while (!yourName);
console.log(yourName);

Эта программа заставит вас ввести имя. Она будет спрашивать снова и снова, пока не получит что-то, что не является путстой текстовой строкой. Применение оператора ! будет преобразовывать значение в условное значение перед тем как отвергнуть его, а все текстовые строки, кроме " ", преобразовываются в условное значение true. Это означает, что оператор цикла продолжает круговое движение пока ему не будет предоставлено что-то, что не является пустой текстовой строкой.

"Сдвиг кода"

Вы возможно заметили отступы, которые были сделаны перед некоторыми предложениями. В JavaScript они не обязательны - компьютер примет программу и без них. На самом деле, даже разделение кода на строки опционально. Вы можете написать программу в виде одной длинной строки, если вам так хочется. Роль отступов внутри блоков сделать так, чтобы структура кода выделялась. В сложном коде, где новые блоки открываются внутри других блоков, может быть сложно увидеть где заканчивается один блок и начинается другой. Благодаря правильным отступам, визуальная форма программы отвечает форме блоков внутри ее. автору нравится использовать два пробела перед кажым открытым блоком, но вкусы отличаются - кто-то использует 4 отступа, а кто-то tab.

"Оператор цикла For"

Многие операторы цикла идут по примеру оператора while. Сначала переменная "счетчика" создается для того, чтобы отследить прогресс цикла. Затем в процесс входит оператор while, чье проверочное выражение обычно проверяет не достиг ли счетчик своего предела. В конце тела оператора цикла счетчик обновляется, чтобы отследить прогресс.

Из-за того, что этот метод так популярен, JavaScript и похожие языки обеспечивают слегка более короткую и более понятную форму, оператор цикла for.

for (var number = 0; number <=12; number = number + 2)
    console.log(number);
// > 0
// > 2
// ... etc.

Эта программа эквивалентна предыдущей, которая показывала четные числа. Единственное изменение в том, что все предложения, которые относятся к состоянию оператора цикла теперь сгруппированы вместе.

Скобки после ключевого слова for должны содержать два символа точки с запятой. Часть до первой точки с запятой запускает цикл, обычно определяя переменную. Вторая часть выражения проверяет может ли цикл продолжаться. Последняя часть обновляет состояние цикла после каждой итерации. Во многих случаях это короче и четче, чем конструкция while.

Вот код который вычисляет 2 в 10 степени, используя оператор for вместо  while:

var result = 1;
for (var counter = 0; counter < 10; counter = counter +1)
    result = result*2;
console.log(result);
// > 1024

Заметьте, что даже без фигурных скобок, предложение внутри оператора цикла имеет отступ, что обозначает то, что оно "принадлежит" к строке над ней.

"Выход из цикла"

Заставить условия цикла произвести значение false - не единственный способ прервать цикл. Есть специальное предложение break. Оно находит первое же значение, которое больше или равняется 20 и делится на 7.

for (var current = 20; ; current++) {
    if (current % 7 == 0)
          break;
}
console.log(current);
//> 21

Используя оператор нахождения остатка (%), мы простым способом проверяем делится ли число на другое число. Если остаток после их деления равняется нулю, значит делится.

Конструкция оператора for в данном примере опускает часть, которая проверяет наступил ли конец цикла. Это означает, что цикличность никогда не прервется до тех пор, пока не исполнится предложение break.

Если оставить предложение break или случайно написать условие, которое всегда производит значение true, ваша программа замкнется в бесконечной цикличности. Программа, замкнувшаяся в бесконечной цикличности, никогда не прекратится, что обычно плохо.

Если создать бесконечную цикличность на одном из примеров на страницах книги, через несколько секунд вам будет предложено остановить код. Если не сделать этого, прийдется закрыть вкладку, в которой вы работаете или в некоторых браузерах прийдется закрыть браузер целиком, чтобы восстановить его.

Ключевое слово continue похоже на break, в том, что оно тоже влияет на прогресс цикличности. Когда в теле цикла встречается команда continue, контроль снимается с тела и цикл продолжается в следующей итерации.

"Лаконичное обновление переменных" 

Особенно выполняя цикличность программа часто нуждается в «обновлении» переменной, чтобы задержать значение основанное на предыдущем значении этой же переменной.

counter = counter + 1;

JavaScript дает сокращение этой операции:

counter +=1

Похожие сокращения работают и для других операторов, такие как result *= 2, чтобы удвоить переменную result или counter -= 1 для обратного отсчета.

Это позволяет еще сократить наш пример со счетчиком.

for (var number = 0; number <= 12; number +=2)
	console.log (number);
Для счетчика +=1 и -=1, есть еще более короткие эквиваленты: counter++ и counter—.

Размещение значения с помощью переключателя (Switch)

Привычно код выглядит так:

if (variable == «value1») action1();
if (variable == «value2») action2();
if (variable == «value3») action3();
else defaultAction();

Для этого также существует конструкция switch, которое решает такое размещение более прямым способом. К сожалению, синтаксис, который использует JavaScript для этого (унаследовал от C/Java языков программирования), выглядит странно. Цепочка предложений с if выглядит лучше. Вот пример:

switch (prompt(«What is the weather like?»)) {
	case «rainy»:
		console.log(«Remember to bring an umbrella.»);
		break;
	case «sunny»:
		console.log(«Dress lightly.»);
		break;
	case «cloudy»:
		console.log(«Go outside.»);
		break;
	default:
		console.log(«Unknown weather type!»);
		break;
}

В блок switch можно поместить любое количество вариантов case. Программа будет прыгать к варианту, который будет соответствовать значению, которое будет передано функции switch или к варианту default, если не будет найдено ни одного совпадающего значения. Программа начнется с совпадающего варианта даже тогда, когда совпадающий вариант находится под другим вариантом и будет выполняться до предложения break. В некоторых случаях, таких как вариант «sunny» на примере это предложение может использоваться для того, чтобы разделить код между двумя вариантами (в данном случае рекомендуется выйти на улицу в двух вариантах: когда солнечная и облачная погода). Но, будьте осторожны: легко забыть этот break, что станет причиной того, что программа выполнит нежелательный код.

"Использование заглавных букв"

Названия переменных могут не содержать пробелы, однако часто бывает полезно использовать несколько слов, чтобы четко описать, что представляет собой переменная. Вы можете также выбрать вариант названия переменной, когда оно будет состоять из нескольких слов:

fuzzylittleturtle
fuzzy_little_turtle
FuzzyLittleTurtle
fuzzyLittleTurtle

Первый стиль может быть сложно прочесть. Автору нравится то, как выглядят нижние подчеркивания, но их сложнее печатать. Стандартные функции JavaScript и большинство JavaScript программистов используют нижний стиль - они начинают заглавными буквами все слова кроме первого. Не так уж и сложно привыкнуть к таким вещам, а код с разными стилями написания может резать глаз, так что мы будем следовать этой методике.

В некоторых случаях, таких как функция Number, первая буква переменной также пишется с заглавной буквы. Это делается для того, чтобы выделить эту функцию, как конструктор. Что такое конструктор станет ясно в Главе 6. А сейчас важно не беспокоиться об этом очевидном отсутствии последовательности.

"Комментарии"

Часто сырой код не содержит всей информации, которую вы хотите передать другим людям, или он содержит настолько зашифрованную информацию, что люди просто не поймут ее. В других случаях у вас просто будет поэтичное настроение или желание изложить свои мысли в качестве части своей программы. Для этого нужны комментарии.

Комментарий это кусок текста, который является частью программы, но полностью игнорируется компьютером. JavaScript предлагает два способа написания комментариев. Чтобы написать однострочный комментарий, можно использовать два символа слэш (//) и комментарий после них.

var accountBallance = calculateBalance(account);
// It’s a green hollow where a river sings
accountBallance.adjust();
// Madly catching white tatters in the grass.
var report = new Report();
// Where the sun on the proud mountain rings:
addTo Report(accountBalance, report);
// It’s a little valley, foaming like light in a glass.

Комментарий // идет только до конца строки. А секция текста между /* и */ будет проигнорирована вне зависимости от того содержит ли она несколько строк. Это часто полезно для добавления больших кусков информации о файле или куску программы.

/*
I first found this number scrawled on the back of one of my notebooks a few years ago. Since then, it has often  dropped by, showing up in phone numbers and the serial numbers of products that I’ve bought. It obviously likes me, so I’ve decided to keep it.
*/
var myNumber = 11213;

"Заключение"

Теперь вы знаете, что программа состоит из предложений, которые иногда содержат другие предложения. Предложения могут содержать выражения, которые в свою очередь могут состоять из выражений меньшего размера.

Располагая предложения одно за другим мы получаем программу, которая выполняется сверху вниз. Вы можете вставлять помехи в поток команд управления, используя условные (if, else или switch) и циклические (while, do и for) предложения.

Переменные могут быть использованы для того, чтобы разместить кусочки данных под определенным именем, и они полезны для того, чтобы отслеживать состояние вашей программы. Среда являет собой набор переменных, которые определены.Системы JavaScript всегда закладывают несколько полезных стандартных переменных в вашу среду.

Функциями являются специальные значения, которые содержат кусок программы. Вы можете вызывать их путем написания functionName(argument1, argument2). Такой вызов функции является выражением и может произвести значение.



<Глава  3 / Функции>

«Люди думают, что информатика это искусство гениев, однако существующая реальность обратная - просто много людей надстраивают поверх того, что построили другие, как стена из маленьких камней.» - Дональд Кнут

Вы знакомы с такими значениями функций, как alert и знаете, как вызывать их. Функции являются хлебом и маслом JavaScript программирования. Концепция обертывания куска программы в значение может быть полезной в разных ситуациях. Этот инструмент позволяет структурировать крупные программы, снижает количество повторений, ассоциирует имена с суб-программами, а также отделяет суб-программы друг от друга.

Самое очевидное применение функций это определение нового словаря. Создавать новые слова в  прозе на обычном человеческом языке - плохой стиль. Но, в программировании это просто необходимо.

В лексиконе обычного англо говорящего человека около 20 000 слов. Только в нескольких языках программирования наберется 20 000 встроенных команд. И доступный набор слов в основном строго определен, а потому менее гибок, чем человеческий язык. Таким образом, время от времени мы должны добавлять в наш собственный словарный запас новые слова, чтобы избежать повторений.

Определение функции

Определение функции то же самое, что и определение переменной, где значением, передаваемым переменной служит функция. Например, ниже приведен код, который определяет переменную square,  которая относится к функции, которая производит квадрат от заданного числа:

var square = function(x) {
	return x*x;
};

console.log(square(12));
// > 144

 Функция создается выражением, которое начинается с ключевого слова function. /* Функции имеют набор параметров (в данном случае только x) и тело, которое содержит предложения, которые выполняются при вызове функции. Тело функции должно всегда быть обернутым фигурными скобками, даже когда оно содержит только одно предложение (как на предыдущем примере).

У функции может быть несколько параметров или не быть параметров вообще. В следующем примере, переменная makeNoise не содержит ни одного параметра, тогда как power содержит два:*/

var makeNoise = function() {
	console.log(«Pling»):
};

makeNoise ();
//> Pling!


var power = function (base, exponent) {
	var result = 1;
	for (var count = 0; count < exponent; count++)
		result *= base;
	return result;
};

console.log(power(2, 10));
// > 1024

Некоторые функции производят значения, такие как power и square, а некоторые не делают этого, такие как makeNoise, и производят только побочные эффекты. Предложение return определяет то, какое значение вернет функция. Когда контроль команд встречает такое предложение, он сразу выпрыгивает из текущей функции и выдает коду возвращаемое значение. Ключевое слово return без выражения после него заставит функцию вернуть значение undefined.

Параметры и область видимости переменных

Параметры функции ведут себя как обычные переменные, но их начальные значения задаются тем, кто вызывает функцию, а не кодом самой функции.

Важным свойством функций является то, что переменные, созданные внутри них, включая их параметры, локальны для этой функции. Это означает, что, например, переменная result  в примере power будет создаваться вновь и вновь, каждый раз когда функция будет вызываться и эти отдельные воплощения не нарушают поведения друг друга.

Эта локальность переменных применима только к параметрам и переменным заданным с помощью ключевого слова var внутри тела функции. Переменные заданные вне функции называются глобальными, потому что они видимы по всей программе. Вы можете получать доступ к таким переменным внутри функции до тех пор, пока не назначили локальную переменную с таким же именем.

Следующий пример демонстрирует это. Он определяет и вызывает две функции, обе из которых определяют значения переменной x. Первая задает переменную локально и таким образом изменяет только локальную переменную. Вторая не определяет переменную локально, таким образом упоминание переменной x внутри неё относится к глобальной переменной х определенной в верхней части примера.

var x = «outside»;
var f1 = function(){
	var x = «inside f1»;
};
f1();
console.log(x);
//> outside

var = f2 = function (){
	x = «inside f2»;
};
f2();
console.log(x);
//> inside f2

Это поведение позволяет предотвратить непредвиденные конфликты между функциями. Если бы все переменные использовались всей программой пришлось бы предпринимать столько усилий, чтобы ни одно из названий не использовалось бы для двух разных целей. И если бы вы пере использовали название переменной, вы бы увидели странные эффекты от несвязанного кода, который бы влиял на значение вашей переменной. Относясь к локальным переменным функций как к существующим только внутри функций, язык делает возможным чтение и понимание функций как маленьких вселенных без необходимости волноваться сразу обо всем коде.

Составные области видимости переменных

JavaScript разделяет не только глобальные и локальные переменные. Функции могут быть созданы внутри других функций, и создавать некоторую степень локальности.

Например,это достаточно бессмысленная функция имеет две внутренние функции.

var landscape = function(){
	var result = «»;
	var flat = function(size) {
		for (var count = 0; count < size; count++)
			result+="_";
	};
	var mountain = function(size) {
		result += "/";
		for (var count = 0; count<size; count++)
			result +="'";
		result += "\\";
	flat (3);
	mountain (4);
	flat(6);
	mountain(1);
	flat(1);
	return result ;
};

console.log(landscape());
// > ___/''''\______/'\_

Функции flat и mountain могут видеть переменные result, так как они находятся внутри функции, которая определяет их. Но они не могут видеть переменные count друг друга, так как они находятся вне области видимости переменных друг друга. Окужение вне функции landscape не видит переменных, определенных внутри landscape.

Если коротко, каждая локальная область переменных также видит все локальные области, в которую она входит. Набор переменных видимых внутри функции определяется местом этой функции в тексте программы. Все переменные из блоков вокруг определенной функции видимы - и те, что заключены в тело функции включающей определенную функцию и те, что находятся на верххнем уровне программы. Этот подход к видимости переменных назывется лексической сферой действия.

Люди, которые пробуют другие языки программирования могут ожидать, что каждый блок кода между фигурными скобками создают новое окружение. Однако в JavaScript функции являеются единственными элементами, которые создают новую область переменных. Вы также можете использовать отдельно стоящие блоки.

var something = 1;
{
	var something = 2;
	// Сделать что-то с переменной something...
}
// Вне блока опять...

Но переменная something внутри блока относится к той же переменной, что и та, что находится вне его. В действительности, хотя такие блоки и разрешены, они полезны только в том случае, когда вы хотите сгруппировать предложение if или цикличность.

Если вы находите это странным, вы не одни такие. Следующая версия JavaScript представит ключевое слово let, которое будет работать как var, но будет создавать переменные, которые будут локальны только для включающх их блоков, а не включаюих их функций.

"Функции как значения"

Переменные функций обычно работают просто как названия специального куска программы. Такой тип переменной определяется однажды и уже не изменяется. Получается, что так достаточно просто перепутать функцию и её название.

Но они отличаются. Значение функции может делать всё то же самое, что и другие значения - вы можете использовать их в произвольных выражениях, а не просто вызывать их. Можно сохранять значение функции в другом месте, передавать её как параметр другой функции и так далее. Так же, переменная, которая содержит функцию вся так же является обычной переменной и может получать ноаое значение, например:

var launchMissiles = function (value){
	missileSystem.launch("now")
};
if (safeMode)
launchMissiles = function(value){/*ничего не делать*/};

В Главе 5 =, мы обсудим потрясающие вещи, которые можно воспроизводить передавая значения функции в другие функции.

"Нотация объявления функции"

Существует более короткий способ сказать "var square = function...". Ключевое слово "function" можно использовать для начала предложения, как на примере:

function square(x){
	return x * x;
}

Это - объявление функции. Предложение определяет переменную square и указывает на неё в данной функции. Пока не плохо. Однако есть одна тонкость в таком определении функции:

console.log("The future says:", future());

function future(){
	return "We STILL have no flying cars"
}

Этот код будет работать даже если определенная функция находится под кодом. Это потому, что обЪявление функции не является частью обычныго контроля потока команд управления. Они концептуально перемещаются в верхнюю часть своей области переменных и может быть использована любым кодом в этой области. Иногда это полезно, потому что это дает нам свободу расставлять код в таком порядке, который мы считаем правильным, не беспокоясь о том, чтобы назначать функции над тем местом, где они впервые используются.

что происходи когда вы помещаете такое определение функции внутри условного блока if или цикличности? Не делайте этого. Разные платформы JavaScript в разных браузерах традиционно делают разные вещи в таких ситуациях и последний стандарт вообще запрещает это. Если вы хотите, чтобы ваша программа функционировала полноценно, используйте только эту форму предложений определяющую функцию в самом внешнем блоке функции или программы.

function example (){
	function a(){} //Okay
	if (something){
		function b(){} // Danger!
	}
}

"Список вызовов"

Будет полезным посмотреть более пристально на то как управление команд проходит через функции. Вот простая программа, которая несколько раз вызывает функции:

function greet (who){
	console.log("Hello " + who);
}
greet ("Harry");
console.log('Bye');

Течение этой программы выглядит грубо говоря так: вызов greet заставляет поток управления прыгнуть в начало функции (сторока 2). Оно вызывает console.log (встроенную в браузер функцию), которая берет управление, делает свою работу, а затем возвращает управление на строку 2. Затем доходит до конца функции greet, так она возвращается в то место, которое вызывало ее. Строка идущая после опять вызывает console.log.

Схематично поток управления можно показать так:

top
	greet
		console.log
	greet
top
	console.log
top

Из-за того, что функция вынуждена отпрыгивать назад в место вызова, когда она возвращает значение, компьютер должен запомнить контекст из которого была вызвана функция. В одном случает console.log должен отпрыгивать назад к функции greet. В другом случае, он отпрыгивает назад к концу программы.

Место в котором компьютер храни этот контекст называется списком вызовов. Каждый раз, когда вызывается функция, текущий контекст перемещается поверх этого "списка". Когда функция возвращает значение, она удаляет верхний контекст из списка и использует его для продолжения исполнения.
задавая компьютеру дейсвительно сложные вопросы, что заставляет компьютер входить в бесконечное движение туда-сюда между двумя функциями. Другими словами, оно было бы бесконечным, если бы компьютер имел бесконечный список. В данном случае у нас просто закончится место, и "лист взорвется".

function chicken(){
	return egg();
}
function egg (){
	return chicken();
}
console.log (chicken() +" came first.");
//>??

"Опциональные параметры"

Следующий пример кода разрешен и исполняется без проблем:

alert("Hello", "Good Evening", "How do you do?");

Функция alert официально принимает только один параметр. Однако, когда вы вызаваете её таким образом, она не жалуется. Она просто игнорирует другие параметры и показывает "Hello".

JavaScript предельно широких взглядов, когда речь заходит о количестве параметров, которые передаются функции. Если вы передадите слишком много, лишние будут проигнорированы. Если передадите слишком мало, нехватающим параметрам будут назначены значения undefined.

Недостаток этого заключается в том, что существует вероятность того, что вы случайно отправите функции неправильное количество параметров и никто вам об этом не скажет.

Преимущество этого в том, что это поведение может быть использовано для того, чтобы отправить функции опциональные параметры. Например, следующая версия power может быть вызвана либо с двумя параметрами или с одним параметром. В последнем случае экспонентом будет служить два, а сама функция будет вести себя как square.

function power (base, exponent){
	if (exponent == undefined)
		exponent = 2;
	var result = 1;
	for(var count = 0; count < exponent; count++)
		result *= base;
	return result;
}

console.log(power(4));
//> 16
console.log(power(4, 3));
//> 64

В следующей главе мы рассмотрим способ при котором тело функции сможет получить точное количество параметров, которые должны ей передаться. Это полезно, потому что делает возможным  прием функцией любого числа параметров. Например, console.log использует этот способ и выводит все значения, которые ей даны.

console.log("R", 2, "D", 2);
// > R2D2

"Замыкание"

Способность пользоваться функциями как значениями в сочетании с фактом того, что локальные переменные пересоздаются каждый раз когда функция вызывается, поднимает интересный вопрос. Что происходит с локальными переменными, когда вызов функции, вызвавший их, больше не активен?

Следующий пример кода показывает что происходит. Он определяет функцию, wrapValue, которая создает локальную переменную. Затем она возвращает функцию, которае достает и возвращает эту локальную переменную.

function wrapValue(n){
	var localVariable = n;
	return function(){return localVariable;}
}
var wrap1 = wrapValue(1);
var wrap2 = wrapValue(2);
console.log(wrap1());
//>1
console.log(wrap2());
//>2

Это разрешено и работает так как вы на то рассчитываете - вы по-прежнему можете получить доступ к переменной. В действительности, несколько состояний переменной может жить одновременнно, что является еще одной хорошей иллюстрацией того, что локальные переменные действительно пересоздаются для каждого вызова - разные вызовы не могут пренебрегать локальными переменными друг друга.

Способность отсылать к специфическому состоянию локальной переменной в закрывающей функции называется замыканием. Функция, которая "закрывает" некоторые локальные переменные называется замыкающей. Это поведение не только освобождает вас от беспокойства по поводу срока жизни переменных, а еще и позволяет креативно использовать значения функции.

Небольшим изменением мы можем превратить предыдущий пример в способ создать функции, которые умножаются на произвольное количество.

function multiplier (factor){
	return function(number){
		return number*factor;
	};
}

var twice = multiplier(2);
console.log(twice(5));
// > 10

Заданная localVariable в примере wrapValue не нужна, така как параметр сам по себе является локальной переменной.

Представлять программы таким образом требует практики. Хорошей умственной моделью будет думать о ключевом слове функция, как о "заморозке" кода в теле и обертке его в упаковку (значение функции). Таким образом, когда вы читаете предложение return function(...){...}, думайте о том, как возвращается держатель куска расчетов, замороженный для дальнейшего использования.

На примере, функция multiplier возвращает замороженный кусок кода, который сохраняется в переменной twice. Последняя строка вызывает зачение этой переменной, заставляя замороженный код (return number * factor;) активироваться. Она по-прежнему имеет доступ к переменной factor из вызова multiplier, который создал её и в добавок получает доступ к параметру при размораживании, 5, с помощью параметра number.

"Рекурсия"

Для функции в порядке вещей вызывать саму себя, до тех пор пока это не перегружает список вызовов. Функция, которая вызывает саму себя, называют рекурсивной. рекурсия позволяет некоторым функциям быть написанными в разных стилях. Посмотрите, например, на это альтернативное применение power:

function power (base, exponent){
	if (exponent == 0)
		return 1;
	else
		return base*power(base, exponent - 1);
}

console.log(power(2, 3));

Это очень похже на то, как математики определяют возведение в степень и возможно описывает концепцию более элегантным способом, чем вариант с цикличностью. Функция вызывает себя несколько раз с разными параметрами, чтобы добиться повторяющегося умножения.

Однако такое применение имеет одну важную проблему: в типичном JavaScript применении, он почти в 10 раз медленнее цикличной версии. Использование простой цикличности во много раз дешевле, чем  вызов функции несколько раз.

Дилемма между скоростью и элегантностью интересна. Вы можете рассматривать её как постоянство между машиноориентированностью и человекоориентированностью. Почти каждую программу можно ускорить, делая её больше и запутаннее. Программист должен принимать решение об уместном балансе в том или ином случае.

В случае с первым примером функции power, неэлегантная (цикличная) версия по-прежнему достаточно проста и легка в прочтении. Не имеет смысла заменять её рекурсивной версией. Часто, тем не менее, программа сталкивается с такими сложными концепциями, что уступка в эффективности с целью сделать программу более понятной становится привлекательным выбором.

Основное правило, которое повторяется многими программистами и с чем автор полностью согласен: не беспокойтесь об эффективности до тех пор пока вы наверняка не будете уверены в том, что программма слишком медленная Если это так, выясните какие части отнимают больше всего времени и начните заменять элегантность на эффективность в этих частях.

Конечно, это правило не должно означать, что можно принебрегать производительностью. Во многих случаях, как например в функции power, не очень много простоты приобретается элегантностью. И иногда опытный программист сразу видит, что простой вариант не будет достаточно быстрым.

Причина, по которой автор подчеркивает эту дилемму, состоит в том, что удивительно много начинающих программистов фанатично концентрируются на эффективности, даже в мельчайших деталях. Результатом становятся больше, более сложные и часто менее правильные программы, которые дольше писать, чем более понятные эквиваленты и обычно они работают незначительно быстрее.

Однако рекурсия не всегда является менее эффективной альтернативой цикличности. Некоторые проблемы гораздо легче решить рекурсией. В большинстве случаев это проблемы, которые требуют выполнения нескольких веток, каждая из которых может и дальше разветвляться в еще большее количество ветвей.

Рассмотрите эту задачку: начиная с 1, и продолжая прибавлять 5 или умножать на 3, можно произвести бесконечное множество новых чисел. Как бы вы написали функцию, которая получив число, пытается найти последовательность таких добавлений и умножений, чтобы произвести это число? Например, число 13 может быть достигнуто сначала умножением на 3 и затем добавлением 5 дважды, а число 15 невозможно получить вовсе.

Вот рекурсивное решение этой задачи:

function findSolution(target) {
	function find (start, history){
		if (start == target)
			return history;
		else if (start > target)
			return null;
		else
			return find(start + 5, "(" + history + " + 5)") || find(start *3, "(" + history + " * 3)");
	}
	return find (1, "1");
}

console.log(findSolution (24));
// > (((1 * 3) + 5) * 3)

Заметьте, что необязательно эта программа найдет кратчайшую последовательность операций. Она удовлетворена тем, что находит хотя бы какую-то последовательность.

Автор не ожидает того, что вы сразу сможете увидеть как это работает. Но давайте пройдемся по этому примеру, что позволит нам хорошо потренироваться в рекурсивном мышлении.

Внутренняя функция find осуществляет ту самую рекурсию. Она забирает два параметра - текущее число и текстовую строку, которая записывает то, как мы достигли этого числа и возвращает либо текстовую стороку, которая показывает как добраться до цели или 0.

Чтобы сделать это, функция выполняет одно из трех действий. Если текущее число равняется переменной target, текщее значение переменной history является путем достижения переменной target, то переменная history просто возвращается. Если текущее значение больше, чем target, дальше просматривать history не имеет смысла, так как обе операции - прибавление и умножение будут только увеличивать число. И, в посленем случае, если мы всё еще ниже значения target, функция пытается произвести оба пути, которые начинаются с текущего числа, вызывая себя дважды, по разу на каждый из разрешенных следующих сценариев. Если первый вызов возвращает что-то, что не является нулем, он возвращает это что-то. При ином сценарии, второй вызов возвращается вне зависимости от того, производит он текстовую строку и ли null.

Чтобы лучше понимать, как эта функция производит эффект, который мы ищем, давайте посмотрим на все вызовы переменной find, которые были сделаны при поиске решения для числа 13.

find (1, "1")
	find(6, "(1+5)")
		find (11, "((1+5)+5)")
			find(16, "(((1+5) + 5) + 5)")
				too big
			find(33, "(((1+5)+5)*3)")
				to big
		find (18, "((1+5) + 5) * 3)")
			too big
	find (3, "( 1 * 3)")
		find(8, "((1*3) + 5)")
			find(13, "(((1*3) +5)+5)")
				found!

Отступы демонстрируют глубину листа вызовов. В первый раз, когда вызывается find, она вызывает себя дважды, чтобы проверить решения, начинающиеся с (1+5) и (1*3). Первый вызов пытается найти решение, которое начинается с (1+5) и, используя рекурсию, проверяет каждое решение, которое дает число меньшее или равняющееся значению переменной target. Поскольку она не находит решение, которое совпадает с target, оно возвращает null первому вызову. Там оператор || вызывает процесс, который проверяет (1*3). У этого вызова больше успеха, так его первый рекурсивный вызов и потом еще один рекурсивный вызов достигает значения target, 13. Самый внешний рекурсивный вызов возвращает текстовую строку, и каждый из операторов || в промежутке передает эту текстовую строку, в итоге возвращая нам решение.

"Растущие функции"

Есть еще две более менее естественных причины применения функций в программе.

Первая, когда ты осознаешь, что пишешь очень похожий код несколько раз. Нам хотелось бы избежать этого, так как чем больше кода, тем больше места для ошибок и больше материала необходимо прочитать человеку в попытке понять программу. Таким образом мы возьмем повторяющуюся фунциональность, найдем хорошее название для нее, и превратим в функцию.

Вторая возникает из необходимости функциональности, которая еще не была написана и выглядит достойной своей собственной функции. Вы начнете с того, что назовете функцию, а затем напишете ее тело. Вы можете даже начать писать код, который будет использовать функцию перед тем как определите саму функцию.

То, насколько трудно придумать название функции хороший показатель того, насколько ясная концепция, которую вы хотите обернуть в неё. Пройдемся по примеру.

Мы хотим написать программу, которая печатает два числа, число коров и цыплят на ферме, со словами Cows и Chickens после них и нулями вставленными перед ними, таким обрвзом, чтобы у нас всегда получалось значение из трех чисел.

007 Cows
011 Chickens

Тут очевидно присутствует запрос на функцию с двумя параметрами. Давайте начнем писать код.

function printFarmInventory (cows, chickens){
	var cowString = String(cows);
	while (cowString.length < 3)
		cowString = "0" + cowString;
	console.log(cowString + " Cows");
	var chickenString = String(chickens);
	while (chickenString.length < 3)
		chickenString = "0" + chickenString;
	console.log(chickenString + " Chickens");
}
printFarmInventory(7, 11);

Добавляя свойство .length после значение текстовой строки даст на длину этой текстовой строки. Таким образм, цикличность while продолжает добавлять нули перед числовыми текстовыми строками до тех пор пока они не достигнут длины по крайней мере 3 символов.

Миссия выполнена! Но перед тем, как отправить фермеру код (вместе с увесистым инвойсом, конечно), он звонит нам и говорит, что также хочет считать свиней, и не могли бы мы пожалуйста расширить программное обеспечение и печатать еще и свиней?

Конечно можем. Но, перед тем как копировать и вставлять еще раз эти четыре строки, мы останавливаемся и пересматриваем подход. Должен быть способ получше. Вот первая попытка:

function prontZeroPaddedWithLabel (number, label) {

	var numberString = String(number);
	while (numberString.length < 3)
		numberString = "0" + numberString;
	console.log(numberString + " "+label)
}
function printFarmInventory (cows, chickens, pigs){
printZeroPaddedWithLabel (cows, "Cows");
printZeroPaddedWithLabel (chickens, "Chickens");
printZeroPaddedWithLabel (pigs, "Pigs");
}
printFarmInventory(7, 11, 3);

Работает! Но название printZeroPaddedWithLabel звучит немного странно. Оно соединяет три вещи - печать, добавление нулей, и добавление ярлыка в единственную функцию.

Вместо того, чтобы устранять повторяющуюся часть нашего кода, давайте попробуем выбрать единую концепцию.

function zeroPad(number, width){
	var string = String(number);
	while (string.length < width)
		string = "0" + string;
	return string;
}

function printFarmInventory (cows, chickens, pigs) {
	console.log(zeroPad(cows, 3) + " Cows");
	console.log(zeroPad(chickens, 3) + " Chickens");
	console.log(zeroPad(pigs, 3) + " Pigs");
}

printFarmInventory(7, 16, 3);

Функция с отличным, очевидным названием zeroPad облегчает восприятие того, что она выполняет для того человека, который её читает. И она будет полезна для любой ситуации, а не только для конкретной программы. Например, можно использовать её для того, чтобы печатать отлично расположенные таблицы чисел.

Насколько умной и универсальной должна быть наша функция? Мы могли бы написать от ужасно простой функции, которая бы просто вставляла три цифры до тех пор пока число не становилось бы трехзначным до сложной обобщающей форматирование чисел системы, которая справляется с дробными числами, отрицательными числами, размещением точек, добавлением других символов и так далее.

Полезный принцип - не добавлять продуманности до тех пор, пока вы не поймете, что это будет действительно полезно. Вам может хотетться написать общие фрэймворки для каждого кусочка функционала с которым вы будете сталкиваться. Откажитесь от этой идеи. Так вы не сделаете ничего действительно нужного, а закончите написанием огромного кода, который никогда никто не будет использовать.

"Функции и побочные эффекты"

Функции можно грубо разделить на те, которые вызываются для побочных эффектов и те, которые вызываются для возврата их значений. (Хотя возможен сценарий при котором реализуются обе цели).

Первая помогающая функция в фермерском примере, printZeroPaddedWithLabel, вызывается для побочного эффекта: она печатает строку. Вторая версия, zeroPad, вызывается для возврата значения. Нет совпадения в том, что второй является более полезным и используется в большем количестве ситуаций, чем первый. Функции, которые могут создавать значения, проще комбинировать в новых ситуациях, чем функции, которые напрямую генерируют побочные эффекты.

Чистая функция это отдельный тип функции производящей значения, который не только не содержит побочных эффектов, но и не зависит от побочных эффектов из другого кода - например, он не читает глобальные переменные, которые иногда могут быть изменены другим кодом. Чистая функция обладает таким приятным свойством, что при вызове с одними и теми же параметрами она производит одно и то же значение (и не делает ничего больше). Это облегчает рассуждения о ней. Вызов твкой функции может быть ментально заменен ее результатом не меняя значение кода. Когда вы не уверены в том, корректно ли работает функция, вы можете протестировать ее простым вызовом и понять работает ли она в данном контексте. Она сработает в любом контексте. Нечистые функции могут возвращать разные результаты в зависимости от многих факторов и иметь побочные эффекты, которые может быть сложно проверить и обдумать.

При этом нет необходимости переживать о том, что ваша функция не является чистой и вести священную войну с тем, чтобы изгнать её из своего кода. Побочные эффекты часто бывают полезными. Например, у нас не получилось бы написать чистую версию функции console.log, хотя она определенно полезна. Некоторые операции также легче выразить эффективным способом, используя побочные эффекты. Таким образом скорость вычислений может быть веским аргументом против чистоты.

"Заключение"

Эта глава научила вас как писать собственные функции. Ключевое слово function(){}, когда используется как выражение, может создать значение функции. Когда используется в качестве предложения, оно может быть использовано для того, чтобы объявить переменную и назначить ей функцию в качестве значения.

// Создадим значение функции f
var а = function(a){
	console.log(a+2);
};

// Объявим g в качестве функции
function g(a,b){
	return a * b ; 3.5;
}

Ключевой аспект понимания функций это понимание локальных областей видимости переменных. Параметры и переменные объявленные внутри функций являются локальными для функции, пересоздаваемые каждый раз когда функция вызывается и невидимые вне ее. Функции объявленные внутри других функций имеют доступ к локальной области переменных внешней функции.

Разделение задач, которые выполняет ваша программа, на разные функции очень полезно. Вам не придется повторяться, и функции могут сделать программу более читабельной, группируя код в концептуальные куски в таком же стиле, как главы и разделы организуют обычный текст.

"Структуры данных: Объекты и массивы данных"

- Меня дважды спрашивали: "Мистре Бэбдж, пожалуйста, скажите, если предоставить машине неправильные числа, получим ли мы правильные ответы?" Я не могу должным образом осознать степень запутанности идей, которая могла вызывать подобный вопрос.

Числа, логические значения, текстовые строки являются кирпичами из которых строятся структуры данных. Но вы не сможете построить дом из одного кирпича. Объекты позволяют нам группировать данные, включая другие объекты, вместе и таким образом строить более сложные структуры.

Программы, которые мы строили до сих пор были серьезно затруднены тем фактом, что они работали за счет простых типов данных. Эта глава добавит базовое понимание структур данных в ваш арсенал. К ее концу, вы узнаете достаточно, чтобы начать писать полезные программы.

В этой главе мы разберемся с более менее реалистичным примером программирования, который познакомит с концепциями, которые применимы к решению конкретной проблемы. Пример кода будет часто построен на функциях и переменных, с которыми мы уже познакомились.

"Белка оборотень"

Время от времени, обычно между 8 и 10 вечера, Жак обнаруживает себя превратившмся в маленького пушистого грызуна с густым хвостом.

С одной стороны, Жак доволен тем, что у него не классический случай ликантропии. Превращение в белку может вызвать меньшее количество проблем, чем превращение в волка. Вместо того, чтобы беспокоиться о том, как бы не съесть соседа (что было бы странно), он беспокоится о том, как бы его не съела соседская кошка. После двух случаев, когда он проснулся на ненадежно тонкой ветке верхушки дуба, голым и дизориентированным, он решил запирать двери и окна своей комнаты на ночь и оставлял несколько лесных орешков, чтобы было чем заняться.

Это позволило избавиться от проблем с кошкой и дубом. Однако, Жака до сих пор беспокоит его недуг. Непостоянные случаи трансформации заставляют его подозревать о том, что что-то вызывает их. Некоторое время, он думал, что это случалось тогда, когда он трогает деревья. Он полностью прекратил их трогать и даже избегал проходить мимо них. Но проблема не отступала.

Переключившись на более научный подход, Жак собирается вести ежедневный журнал того, что он делал в этот день и трансформировался ли он. С помощью этих данных он надеется сузить условия, которые вызывают трансформацию.

Первым делом он разработал структуру данных, чтобы хранить эту информацию.

"Наборы данных"

Для того, чтобы работать с кусками цифровых данных, мы для начала найдем способ предоставления их памяти машины. Например, в качетсве простого примера, мы хотим представить набор чисел: 2, у, 5, 7 и 11.

Мы можем быть вполне изобретательными с помощью текстовых строк, которые могут быть любой длины, так что мы можем заложить много данных в них - и использовать "2, 3, 5, 7, 11" как представление. Но это странно. Вам придется каким-то образом вытащить цифры и конвертировать их обратно в числа, чтобы получить к ним доступ.

К счастью, JavaScript предоставляет специалый тип данных, который призван сохранять последовательности значений. Они назыааются массивами (arrays) и пишутся как список значений между квадратными скобками, разделенными запятыми.

var listOfNumbers  = [2, 3, 5, 7, 11];
console.log(listOfNumbers[1]);
//>3
console.log(listOfNumbers[1-1]);
//>2

Нотация, которая позволяет доставать элементы внутри массивов также использует квадратные скобки. Пара квадратных скобок сразу после выражения, с другим выражением внутри них, просмотрит элемент выражения слева, который соответствует индексу, заданному выражением внутри скобок.

Первый индекс массива данных обозначается 0, а не 1. Таким образом, первый элемент может быть вызван с помощью listOfNumbers[0]. Если у вас нет опыта программирования, вам может потребоваться некоторое время, чтобы привыкнуть к этому правилу. Однако счет от 0 имеет давнюю традицию в технологии, и до тех пор пока вы следуете ему (что предполагает использование JavaScript), оно будет работать правильно.

"Свойства"

Мы уже видели несколько подозрительных выражений типа myString.length (чтобы узнать длину текстовой строки) и Math.max (функция выявленяя максимального значения) в предыдущих примерах. Эти выражения получают доступ к свойствам некоторых значений. В первом случае, мы получаем доступ к свойству length значения myString. Во втором, мы получаем доступ к свойству под названием max в объекте Math (который является набором математических значений и функций).

Почти все JavaScript значения имеют свои свойства. Исключениями являются null и undefined. Если вы попробуете получить доступ к свойствам одного из этих не значений, вы получите ошибку.

null.length;
// > TypeError: Cannot read property 'length' of null

Два самых известных способа получить доступ к свойствам в JavaScript - с помощью точки и квадратных скобок. Оба value.x и value[x] получают доступ к свойству value - но не обязательно к одному и тому же. Разница между ними заключается в том, как интерпретировать x. Когда используешь точку, часть после нее должна являться действующим названием переменной и она напрямую называет свойство. Когда используешь квадратные скобки, выражение между ними оценивается для того, чтобы получить название свойства. Таким образом value.x достает свойство x из значения value, а value[x] пытается оценить выражение x и использует в качестве результата название свойства.

Так что, если вы знаете, что свойство, которое вам нужно, называется length, вы пишете value.length. Если вы хлотите вытащить свойство являющееся значением i в некоторой переменной, в пишите value[i]. И поскольку название свойств могут быть любым текстом, если вы хотите достать свойство "2" или "John Doe", вы должныиспользовать квадратные cкобки: value[2] или value["John Doe"]. Так необходимо делать, даже если вы заранее знаете точное название свойства, потому что ни "2", ни "John Doe" не являются действующим названием переменной и таким образом не могут быть доступны с помощью точки.

Элементы внутри массива сохранены в свойстах. Так как названия этих свойств являются числами и нам часто нужно получить их название из переменной, мы должны использовать скобки, чтобы получить доступ к ним. Свойство .length  массива данных говорит нам о количестве элементов, которое он содержит. Это название свойства является действующим названием переменной и мы знаем ее название заранее и чтобы получить длину массива, вы обычно пишите array.length, потому что это легче, чем array["length"].

"Методы"

Оба текстовые строки и объекты массива данных содержат в дополнение к свойству length, набор свойств, которые относятся к значениям функции.

var doh = "Doh";
console.log(typeof doh.toUpperCase);
//> function
console.log(doh.toUpperCase());
// DOH

Каждая текстовая строка имеет свойство toUpperCase. Когда оно вызывается, оно возвращает копию текстовой строки, в которой все буквы конвертируются в заглавные. Есть также функция toLowercase. Вы можете догодаться о том, как она действует.

Интересно, что даже при том, что вызов функции toUpperCase не требует передачи параметров, функция каким-то образом получает доступ к текстовой строке "Doh", того значения, чье свойство мы вызвали. Принцип работы описан в Главе 6.

Свойства, которые содержат функции, обычно называются метоами значения, к которому они относятся. Как в случае с "toUpperCase является методом текстовой строки".

Этот пример показывает некоторые методы, которые есть у объектов массива данных.

var mack = [];
mack.push("Mack");
mack.push("the","Knife");
console.log(mack);
//> ["Mack", "the", "Knife"]
console.log(mack.join(" "));
//> Mack the Knife
console.log(mack.pop());
//> Knife
console.log(mack);
//> ["Mack","the"]

Метод push может быть использован для того, чтобы добавить данные в конец массива. Метод pop делает обратное, он убирает значение на конце массива и возвращает его. Массив текстовых строк может быть сокращен до одной единственной текстовой строки с помощью метода join. Параметр передаваемый методу join определяет текст, который склеивает элементы массива.

"Объекты"

Вернемся к белке-обортню. Набор дневных записей в журнал может быть представлен как массив данных. Но записи не состоят просто из чисел или текстовых строк - каждая запись требует сохранения списка действий и логического значения, которое указывает на то, превратился ли Жак в белку. Идеально, мы бы хотели сгруппировать эти значения вместе в единое значение и затем положить эти сгруппированные значения в массив журнальных записей.

Значения типа объект являются произвольным набором саойств и мы можем добавить или удалить эти свойства когда захотим. Один способ создать объект - использовать фигурные скобки.

var day1 = {
	squirrel: false,
	events: ["work", "touched tree", "pizza", "running", "television"]
};
console.log(day1.squirrel);
//>false
console.log(day1.wolf);
//> undefined
day1.wolf = false;
console.log(day1.wolf);
//> false

Значит фигурные скобки имеют два назначения в JavaScript. В начале предложения, они начинают блок предложений. В любой другой позиции, они описывают объект. К счастью, почти никогда не требуется нчинать предложение с облаченного в фигурные скобки объекта, и в типичных программах, нет двусмыленности между этими двумя применениями.

Чтение свойства, которое не существует даст нам значение undefined, которое случается тогда, когда мы пытаемся прочитать свойство wolf в предыдущем примере.

Возможно назначить значение к выражению свойства с помощью оператора =. Это заменит значение свойства, если оно уже существует или создат новое значение свойства объекта, если не существует.

Чтобы коротко вернуться к нашей модели привязки переменных с помощью щупальцев - привязка свойств похожа. Она забирает значения, но другие переменные и свойства могут содержать такие же значения. Вы можете рассматривать объекты, как осьминогов с любым количеством щупальцев, на каждом из которых написано имя.

Оператор delete отрежет щупальце от такого осьминога. Это унарный оператор, который при применении к выражению достающему свойство, может удалить названное свойство из объекта. Обычно этого не делают, но это возможно.

var anObject = {left: 1, right: 2};
console.log(anObject.left);
//>1
delete anObject.left;
console.log(anObject.left);
//> undefined
console.log("left" in anObject);
//> false
console.log("right" in anObject);
//> true

Бинарный оператор in, при применении к текстовой стороке и объекту возвращает логическое значение, которое указывает есть ли у данного объекта это свойство. Разница между установкой свойства undefined и фактическим удаелнием заключается в том, что в первом случае, у объекта остается свойство (у него просто не особо интересное значение), тогда как во втором случае свойство просто больше не существует и возвразает false.

Таим образом массивы данных являются просто видом объекта, который специализируется на том, что сохраняет последовательности вещей. если вы оцените typeof [1, 2], вы получите значение 'object'. Вы можете смотреть на них как на длинных плоских осьминогов с руками в аккуратный ряд, обозначенными числами.

Давайте представим журнал Жака, как массив объектов.

var journal = [
	{events: ["work", "touched tree", "pizza", "running", "television"],
	squirrel: false},
	{events: ["work", "ice cream", "cauliflower", "lasagna", "touched tree", "brushed teeth"],
	squirrel: false},
	{events: ["weekend", "cyclling", "break", "peanuts", "beer"],
	squirrel: true},
	/* and so on */
];

"Видоизменяемость"

Мы очень скоро перейдем к реальному программированию. Но сначала, разберемся еще в одном последнем куске теории.

Мы видели, что значения объектов могут быть изменены. Типы значений, которые обсуждались в предыдущих главах, такие как числа, текстовые строки, логические значения, все являются неизменяемыми - невозможно изменить существующее значение этих типов. Вы можете комбинировать с помощью них и получать новые значения из них, но когда вы берете конкретное текстовое значение6 это значение всегда будет одинаковым. Текст внутри него может быть изменен. Если вы обращаетесь к текстовой строке, которая содержит "cat", невозможно с помощью другого кода поменять символы так, чтобы оно превратилось в "rat".

С объектами, напротив, конетнт можно изменить, изменяя его свойства.

Когда у нас есть два числа, 120 и 120, мы можем рассматривать, как точь в точь одинаковые числа, не важно относятся ли они к одинаковым физическим частицам. Однако, в объектах есть разница между двумя отношениями к одному и тому же объекту и двумя разными объектамя, которые содержат одинаковые свойста. Рассмотрите слкдующий код:

var object1 = {value: 10};
var object2 = object1;
var object3 = {value: 10};

console.log (object1 == object2);
//> true
console.log (object1 == object3);
//> false

object1.value = 15;
console.log(object2.value);
//> 15
console.log(object3.value);
//> 10

Переменные Object1 и object2 забирают один и тот же объект, вот почему object1 всегда меняет значение object2. Переменная object3 указывает на другой объект, который изначально содержит такие же свойства, как и object1, но живет отдельной жизнью.

Оператор ==  в JavaScript при сравнении объектов вернет true только тогда, когда оба объекта будут иметь в точности одинаковые значения. Сравнивая разные объекты вы получите false, даже если содержимое их будет идентичным. Не существует операции "глубокого" сравнения встроенного в JavaScript, которое выглядит как содержимое объекта, но есть возможность написать его самостоятельно (что будет одним из упражнениц в конце этой главы).

"Записки ликантропа"

Так Жак запускает свой интерпретатор JavaScript и устанавливает необходимое окружение, чтобы вести свой журнал.

var journal = [];

function adddEntry (events, didITurnIntoASquirrel) {
	journal.push({
		events: events,
		squirrel: didITurnIntoASquirrel

	}	);
}

И потом, в 10 вечера или иногда на следующее утро, после того, как он слезал с верхней полки своего книжного шкафа - он записывал свой день.

addEntry(["work", "touched tree", "pizza", "running", "television"], false);
addEntry(["work", "ice cream", "cauliflower", "lasagna", "touched tree", "brushed teeth"], false);
addEntry(["weekend", "cycling", "break", "peanuts", "beer"], true);

Когда у него наберется достаточное количество данных, он собирается вычислить коррелляцию между его белкофикацией и каждым из ежедневных событий и в идеале определить что-то полезное из этих корреляций.

Корреляция это определение зависимости между переменными ("переменные" в статистическом смысле, а не в смысле JavaScript). Обычно они выражаются с помощью коэффициента, который варьируется от -1 до 1. Нулевая корреляция означает, что переменные не связаны между собой, тогда как корреляция 1 указывает на то, что две переменные идеально связаны между собой - если вы знаете одно, значит вы точно знаете другое. Негативное значение также означает то, что переменные идеально связаны между собой, но они противоположны друг другу, - когда одно имеет значение true, другое обязательно будет иметь false.

Для бинарных переменных (логических), коэффициент phi обеспечивет хорошее измерение корреляции и его достаточно легко посчитать. Чтобы рассчитать его, нам нужна таблица n, которая содержит количество раз различные комбинации двух переменных нам встречались. Например, мы можем взять событие "pizza" и поместить его в таблицу:

No squirrel, no pizza = 76
No squirrel, pizza = 9
Squirrel, no pizza = 4
Squirrel, piza = 1

Phi может быть рассчитан используя следующую формулу, где n относится к таблице:

phi = n11n00 - n10n01 / √n1.n0.n.1n.0

Нотация n01 означает количество измерений где первая переменная (белочность) равняется значению false (0), вторая переменная (pizza) равняется true (1). В данном примере n01=9.

Значение n1. относится к сумме всех измерений, где первая переменная равняется true, что согласно нашей таблице равняется 5. А n.0 относится к сумме измерений, где вторая переменная равняется false.

Таким образом для таблицы с пиццей, часть над чертой деления (числитель) будет равняться 1*76 - 4*9 = 40, а часть под ней в знаменателе будет квадратным корнем 5*85*10*80, или √340000. В результате мы получаем

Так мы получаем phi ~  0.069, что является крошечной корреляцией. Поедание пиццы кажется не оказывает влияния на трансформации.

"Вычесление корреляции"

В JavaScript мы можем представить таблицу 2 на 2 с массивами данных из четырех элементов ([76, 9, 4, 1]). Мы могли бы также использовать друггие представления, такие  как массивы, содержащие массивы из по два элемента ([[76, 9], [4, 11]]) или объект с названиями свойств как "11" и "01", но плоский массив прост и создает выражения, которые получают доступ к таблицам приятно просто. Мы будем интерпретировать индексы в массиве, как двухбитные бинарные числа, где самое левое (самые значимое) число относится к переменной "белка", а правое (менее значимое) число к событию. Например, бинарное число 10 относится к случаям, когда Жак превратился в белку, а событие (например "pizza") не произошло. Это случилось 4 раза. И така как бинарное значение 10 это 2 в десятичной нотации, мы сохраним это число в качестве индекса 2 в массиве.

Вот функция, которая рассчитывает коэффициент phi из такого массива.

function phi (table){
	return (table[3]*table[0] - table[2]*table[1]) / Math.sqrt ((table[2]+table[3])*
																(table[0]+table[1])*
																(table[1]+table[3])*
																(table[0]+table[2]));

}

console.log(phi([76, 9, 4, 1]);
//> 0.068599434

Вот собственно простая трансляция формулы phi в JavaScript. Функция Math.sqrt вычисляет квадратный корень, что обеспичивается объектом Math, который является стандартным для окружения JavaScript. Нам необходимо сложить два поля из таблице, чтобы получить значения как n1. , потому что суммы рядов или колонок не созранены напрямую в нащей структуе данных.

Жак вел записи в свой журнал в течение 3х месяцев. Данные результатов доступны в песочнице кода для этой главы, гне они сохранены в переменной JOURNAL и в загружаемом файле.

Чтобы получить таблицу два на два для отдельного события из журнала, мы должны содать цикличность через все записи и подвести итог сколько раз событие имело место быть в зависимости от трансформаций в белку.

function hasEvent (event, entry) {
	return entry.events.indexOf(event) !=-1;
}

function tableFor(event, journal){
	var table = [0, 0, 0, 0];
	for (var i = 0; i < journal.length; i++){
		var entry = journal [i], index = 0;
		if (hasEvent (event, entry)) index += 1;
		if (entry.squirrel) index +=2;
		table[index] += 1;
	}
	return table;
}

console.log(tableFor("pizza", JOURNAL));
//> [76, 9, 4, 1]

Функция hasEvent проверяет содержит ли запись заданное событие. Массивы содержат метод indexOf, который пытается найти заданное значение (в данном случает навание события) в массиве и возвращает индекс на котором оно было найдено или -1, если событие не было найдено в записи.

Тело цикличности в функции tableFor выясняет в какую ячейку в таблице попадает каждая запись, проверяя содержит ли она заданное событие, которым она интересуется и связано ли это событие как-то с превращением в белку. Цикличность таким образом добавляет единицу к номеру в массиве, который отвечает за конкретную ячейку в таблице.

Теперь у нас есть инструменты для вычисления индивидуальных корреляций. Последний шаг остался для того, чтобы найти корреляцию для каждого типа событий, который был записан и посомтреть не выделяется ли что-то. Но как нам запомнить эти корреляции, после того, как мы рассчитаем их?

"Объекты как карты"

Один способ - сохранить все корреляции в массив, используя объекты со свойствами namу и value. Но это это может затруднить процесс рассмотрения корреляции заданного события: придется создавать цикличность через весь массив, чтобы найти объект с правильным названием. Мы иогли бы обхватить процесс поиска в функцию, но нам по-прежнему пришлось бы писать много кода, а компьютер выполнял бы больше рвботы чем нужно.

Лучшим способом будет использовать свойства объекта названные как и события. Мы можем использовать квадратные скобки, чтобы создать и прочитать свойства и можем использовать оператор in, чтобы проверить существует ли заданное свойство.

var map = {};
function storePhi(event, phi){
	map[event] = phi;
}
storePhi("pizza", 0.069);
storePhi("touched tree", -0.081);
console.log("pizza" in map);
//> true
console.log(map["touched tree"]);
// > -0.081

Карта - это способ перехода от значений одной области ( в данном случае, название событий) к соответствующим значениям в другой области ( в данном случае, коэффициент phi).

Есть несколько потенциальных проблем использования объектов таким образом, которые мы обсудим в главе 6, но пока мы не будем об этом беспокоиться.

Что если мы захотим найти все события, для которых мы сохранили коэффициент? Свойства не формируют предсказуемые серии, как в случае с массивами, так что мы не сожем использовать обычную for цикличность. JavaScript предоставляет конструкцию цикличности специально для проверки свойств внутри объекта. Она выглядит немного как обычная for цикличность, но отличается использованием слова in.

for (var event in map)
	console.log("the correlation for '"+ event + "'is" + map[event])
//> The correlation for 'pizza' is 0.069
//> The correlation for 'touched tree' is -0.081

"Финальный анализ"

Чтобы найти все типы событий, которые находятся в наборе данных, мы просто пропускаем каждую запись по очереди и затем проходим по всем событиям в этой записи. Мы забираем коэффициенты phi из объекта, которые содержат значения корреляций для всех типов событий, которые мы видели до сих пор. Каждый раз, когда мы встречаем тип, который еще не находится в объекте phi, мы вы высчитываем его корреляцию и добавляем к объекту.

function gatherCorrelations (journal) {
	var phis = {};
	for (var entry = 0; entry < journal.length; entry++) {
		var events = journal[entry].events;
		for (var i = 0; i < events.length; i++) {
			var event = events[i];
			if (!(event in phis))
				phis[event] = phi(tableFor(event, journal));
		}
	}
	return phis;
}

var correlations = gatherCorrelations(JOURNAL);
console.log(correlations.pizza);
//> 0.068599434

Давайте посмотрим, что у нас получилось.

for (var event in correlations)
	console.log(event + ": " + correlations[event])

Кажется, что большинство корреляций лежит близко к нулю. Поедание моркови, хлебы или пуддинга очевидно не вызывает белочную ликонтропию. Действительно кажется, будто это чаще происходит по выходным. Давайте отфильтруем резултаты, чтобы показать только корреляции больше 0.1 или меньше -0.1.

for (var event in correlations){
	var correlation = correlations[event];
	if (correlation > 0.1 || correlation<-0.1)
		console.log(event + ": " + correlation);
}

Ага! Есть два фактора, чья корреляция определенно сильнее остальных. Поедание орешков имеет сильный позитивный эффект на шанс превращения в белку, тогда как чистка зубов имеет значительный негативный эффект.

Интересно, а давайте кое-что попробуем.

for (var i = 0; i < JOURNAL.length; i++){
	var entry = JOURNAL[i];
	if (hasEvent("peanuts", entry) && !hasEvent("brushed teeth",entry))
		entry.events.push("peanut teeth");
}
console.log(phi(tableFor("peanut teeth", JOURNAL)));

Вот, тут не ошибиться! Феномен происходит ровно тогда, когда Жак ест орешки и не чистит зубы. Если бы только он не был таким неряхой в отношении своей зубной гигиены, он бы никогда и не заметил этой своей странности.

Зная это, Жак просто прекращает есть орешки и понимает, что это кладет конец его превращениям.

Всё хорошо с Жаком до поры довремени. Но спустя несколько лет, он лишается работы и случайно вынужден начать работать в цирке, где он выступает как Невероятный Человек-Белка, набивая свой рот ореховым маслом перед каждым выступлением. Однажды, когда ему надоело его жалкое существование, Жак решил не превращаться обратно в человека, прыгнул в щель циркового шатра и исчез в лесу. Никто его больше не видел.

"Дальнейшее изучение массивов данных"

Перед тем, как заканчивать эту главу автор хочет показать еще несколько концепций относящихся к объектам. Начнем с представления некотрых часто используемых методов работы с массивами.

Мы видели методы push и pop, которые добавляют и убирают элементы в конце массива. Соответствующие методы, добавляющие и убирающие элементы в начале массива называются unshift и shift.

var todoList = [];
function rememberTo(task){
	todoList.push(task);
}
function whatIsNext(){
	return todoList.shift();
}
function urgentlyRememberTo(task) {
	todoList.unshift(task);
}

Эта программа управляет листом задач. Ты добавляешь задачи в конец листа вызывая rememberTo('eat'), и когда вы готовы сделать что-то, вы вызываете whatIsNext() чтобы получить (и удалить) передний элемент из списка. Функция urgentlyRememberTo также добавляет заданиче, но добавляет вперед, вместо того, чтобы добавлять назад.

У метода indexOf есть брат lastIndexOf, который начинает искать заданный элемент в конце массива вместо того, чтобы искать впереди.

console.log([0, 1, 2, 3, 4].slice(2, 4));
//> [2, 3]
//> [2, 3, 4]

Когда конечный индекс не задан, slice заберет все элементы, начиная с указанного индекса. К текстовым сторокам тоже можно применить метод slice, и он даст похожий эффект.

Метод concat можно использовать для склеивания массивов. Он выполняет такую же функцию как оператор + для текстовых строк. Следующий пример показывает concat и slice в действии. Он берет массив и индекс, возвращая новый массив, который является копией оригинального массива с удаленным из заданного индекса элементом.

function remove(array, index){
	return array.slice(0, index)
		.concat (array.slice(index + 1));
}
console.log(remove(['a', 'b', 'c', 'd', 'e'], 2));
//> ['a', 'b', 'd', 'e']

"Текстовые строки и их свойства"

Мы можем прочитать такие свойства как length и toUpperCase из значений текстовых строк. Но, если попробовать добавить новое свойство, это не сработает.

var myString = "Fido";
myString.myProperty = "value";
console.log(myString.myProperty);
//> undefined

Значения типа текстовых строк, чисел и логических значений не являются объектами и, не смотря на то, что язык не жалуется если вы пытаетесь задать новое свойство для них, он просто не сохраняет такие свойства. Значения постоянны и не могут быть изменены.

Но эти типы значений имеют несколько встроенных свойств. Каждая текстовая строка имеет набор методов. Самые полезные из них возможно slice и indexOf, которые напоминают методы массивов с таким же названием.

console.log("coconuts".slice(4,7));
//> nut
console.log("coconuts".indexOf("u"));
//> 5

Есть одно отличие, которое заключается в том, что метод indexOf для текстовой строки может взять в качестве параметра более одного символа,  тогда как соответствующий метод для массива будет искать только один элемент.

 console.log("one two three".indexOf("ee"));
 //> 11

Метод trim удалит пробелы (пробелы, новые стоки, отступы, и похожие символы) с начала и до конца текстовой строки.

console.log("  okay \n ".trim());
//> okay

Мы уже видели свойство length применимо к текстовой строке. Получения доступа к отдельным символам в текстовой строке можно добиться с помощью метода charAt, а также просто прочитав прочитав нумерические свойства, как у массивов.

var string = "abc";
console.log(string.length);
//> 3
console.log(string.charAt(0));
//> a
console.log(string[1])
//> b

"Объект arguments"

Когда вызывается функция, к окружению, в котором работает тело функции, добавляется специальная переменная. Эта переменная относится к объекту, который содержит все параметры, которые передаются функции. Запомните, что в JavaScript вам разрешено передавать больше или меньше параметров в функцию, чем сама функция того запрашивает.

function noArguments(){}
noArguments(1, 2, 3); // Это нормально
function threeArguments(a, b, c){}
threeArguments(); // И это тоже

Объект arguments имеет свойство length, которое говорит о том, сколько параметров действительно передано функции. У него также есть свойство для каждого параметра, названные 0, 1, 2, и так далее.

Если это вам чем то напоминает массив, вы правы, это очень похоже на массив. Но этот объект, к сожалению, не имеет никаких методов свойственных массиву (таких как slice или indexOf), так что его немного сложнее использовать, чем массив.

function argumentCounter (){
	console.log("You gave me", arguments.length, "arguments.")
}
argumentCounter("Straw man", "Tautology", "Ad Hominem");
//> You gave me 3 arguments.

Некоторые функции могут забирать любое количество параметров, наприме console.log. Такие обычно проходят по всем значениям с помощью объекта arguments. Они могут помочь создавать очень приятные интерфейсы. Например, вспомните, как мы создавали записи в журнал Жака.

addEntry(["work", "touched tree", "pizza", "running", "television"], false);

Так как он будет вызывать эту функцию много раз, мы можем создать альтернативу, которую будет проще вызывать.

function addEntry(squirrel){
	var entry = {events: [], squirrel: squirrel};
	for (var i = 1; i < arguments.length; i++)
		entry.events.push(arguments[i]);
	journal.push(entry);
}
addEntry(true, "work", "touched tree", "pizza", "running", "television");

Эта версия читает первый аргумент (squirrel) нормальным способом, а затем проходит по остальным параметрам (цикличность начинается с индекса 1, пропуская первый), чтобы собрать их в массив.

"Объект Math"

Как мы видели, Math это собрание относящихся к числам служебных функций, таких как Math.max (максимум), Math.min (минимум), и Math.sqrt(квадратный корень).

Объект Math используется просто как контейнер, который группирует кучу релевантного функционала. Есть толко один объект Math, и он почти никогда не бывает полезным как значение. Скорее, он предоставляет пространство имен, таким образом, что все эти функции и значения не обязаны быть глобальными переменными.

Наличие слишком большого количества переменных загрязняет пространство имен. Чем больше имен используется, тем выше вероятность того, что мы случайно перезапишем существующую переменную. Например, вполне вероятно, что вы захотите назвать что-то именем max в вашей программе. Так как встроенная функция max надежна спрятана внутри объекта Math, нет необходимости беспокоиться о том, что мы перезапишем ее.

Многие языки остановят вас, или по крайней мере предупредят вас, когда вы определите переменную, которая уже занята. JavaScript так не сделает, так что будьте аккуратны.

Вернемся к объекту Math. Если вам понадобится заняться тригонометрией, Math вам поможет. Он содержит cos (косинус), sin (синус), и tan (тангенс), также как и их обратные функции, acos, asin и atan, соответственно. Число π (пи) - или по крайней мере близкое соответствие, которое подходит в виде числа JavaScript, также доступно как Math.PI. (Существует старая традиция в программировании, писать название постоянных значений заглавными буквами.)

function randomPointOnCircle (radius){
	var angle = Math.random()*2*Math.PI;
	return {x: radius * Math.cos(angle),
		y: radius * Math.sin(angle)};
}
console.log(randomPointOnCircle(2));
//> {x: 0.3667, y: 1.966}

Если синус и косинус вам не знакомы, не беспокойтесь. Когда они будут использоваться в этой книге в главе 13, мы их объясним.

Предыдущий пример использует Math.random. Эта функция, которая возвращает новое псевдо случайное число между 0 включительно и 1 (не включительно), каждый раз когда вы его используете.

cosole.log(Math.random());

Хоть компьютеры и являются детерминистскими машинами, они всегда реагируют одинаковым способом, если им дать одинаковые вводные данные - можно заставить их выдавать числа, которые кажутся случайными. Чтобы сделать это, машина сохраняет число (или несколько чисел) в своем внутреннем состоянии. Затем, каждый раз когда случайное число запрашивается, оно выполняет некоторые сложные детерминистские вычисления в своем внутреннем состоянии и возвращает часть результата этих вычислений. Машина также использует этот результат в своем внутреннем состоянии, таким образом чтобы следующее "случайное" число отличалось.

Если мы хотим получить целое случайное число, вместо частичного, мы можем применить Math.floor (который округляет в меньшую сторону до ближайшего целого числа) к Math.random.

console.log(Math.floor(Math.random() * 10));
// > 2

Умножение случайного числа на 10 дает нам число большее или равное 0, и меньше 10. Так как Math.floor округляет в меньшую сторону, это выражение произведет с одинаковой вероятностью число от 0 до 9.

Есть еще функции Math.ceil ("потолок", которое округляет до целого числа), а Math.round (до ближайшего целого числа).

"Глобальный объект"

Глобальная область значений, пространство в котором живут глобальные переменные, также можно рассмотреть как объект в JavaScript. Каждая глобальная переменная существует как свойство этого объекта. В браузерах6 глобальная область сохраняется в переменной  window.

var myVar = 10;
console.log("myVar" in window);
//> true
console.log(window.myVar);
// > 10

"Заключение"

Объекты и массивы (которые являются особыми видами объектов) обеспечивают способы группировать некоторые значения в отдельные значения. Концептуально, это позволяет нам заложить группу относящихся друг к другу вещей в сумку: вместо того, чтобы пытаться обхватить нашими руками все вещи и пытаться держать их по отдельности.

Большинство значений в JavaScript имеют свойства, исключениями являются null и undefined. Доступ к свойствам можно получить с помощью значение.названиеСвойства или значение["названиеСвойства"]. Объекты обычно используют имена своих свойств и содержат более или менее фиксированный их набор. Массивы, наоборот, обычно содержат вариьируемое количество концептуально идентичных значений и используют числа (начиная с 0) в качестве названий для своих свойств.

Существуют и названные свойства массивов, такие как length и несколько методов. Методы - это функции, которые живут в свойствах и (обычно) воздействуют на значения свойствами которого они являются.

Объекты также могут служить в качестве карт, ассоциируя значения с именами. Оператор in может использоваться для того, чтобы узнать содержит ли объект свойство с заданным названием. Такое же ключевое слово можно использовать в цикличности for (for (var name in object)), чтобы поискать среди всех свойств объекта.

Высокоуровневые функции

"Цу-ли и Цу-зу хвастались размерами своих последних программ. "Двести тысяч строк", скзал Цу-ли, " не считая комментариев!" Цу-зу ответил, "Пф, моя уже насчитывает больше миллиона." Учитель Юан-Ма сказал: "Моя лучшая программа состоит из 500 строк". Услышав это, Цу-ли и Цу-зу просветились.
- Мастер Юан-Ма, Книга программирования

"Есть два способа разрабатывать программное обеспечение: делать его таким простым, что в нем очевидно не будет недостатков, или делать его таким сложным, что в нем не будет очевидных недостатков.

Большая программа - дорогая программа, и не только из-за времени, которое приходится тратить на ее создание. Размер почти всегда несет в себе сложность, а вводит в смятение программистов. Смущенные программисты, в свою очередь, чаще всего допускают баги (ошибки) в программах. Большая программа также создает много мест, где ошибки могут прятаться, из-за чего и становится сложно найти.

Давайте коротко вернемся к последним двум программам из введения. Первая - самодостаточная и содержит 6 строчек кода.

var total = 0, count = 1;
while (count<= 10) {
total += count;
count+= 1;
}
console.log (total);

Вторая основана на двух внешних функциях и состоит из одной строки.

console.log(sum(range(1, 10)));

В какой из них скорее всего может завестись баг?

Если мы посчитаем размер определений функций sum и range, вторая программа будет большой - даже больше первой. Однако, все равно, можно поспорить, что она скорее будет правильной.

Она скорее будет правильной, потому что решение описано в словаре, который соответствует решаемой проблеме. Суммируя диапазон чисел не о цикличности и счетчиках, или других незначительных деталях. Но из-за того, что они описаны более простыми концепциями, чем программа в целом, их легче правильно использовать.

Абстракция

В контексте программирования, эти типы словарей обычно называются абстракциями. Абстракции скрывают детали и дают нам способность говорить о проблемах на более высоком (абстрактном) уровне.

Как аналогия, сравните эти два рецепта горохового супа:

"Положите 1 чашку сухого гороха на человека в контейнер. Добавьте воды, чтобы она покрыла горох. Оставьте горох в воде на 12 часов. Вытащите гороз из воды и положите его на сковородку. Добавьте четыре чашки воды на человека. Накройте сковородку и тушите горох в течение двух часов. Возьмите половины луковицы на человека. Разрежьте ножом на части. Добавьте в горох. Возьмите стебель сельдерея на человека. Порежьте его ножом на части. Добавьте в горох. Возьмите морковку на человека. Порежьте на части. Ножом! Добавьте в горох. Готовьте еще 10 минут.

И второй рецепт:

"На человека: 1 чашка сухого гороха, половина порезанного лука, стебель сельдерея и морковь.

Замочите горох в течение 12 часов. Тушите в течение 2х часов в 4х чашках воды (на человека). Порежьте и добавьте овощи. Готовьте еще 10 минут.

Второй короче и легче интерпретировать. Но вам нужно понимать немного больше кулинарных терминов - замочите, потушите, порежьте, и возможно, овощи.

Программируя, мы не можем рассчитывать на то, что в словаре будут все слова, которые нам нужны. Таким образом, мы можем столкнуться с необходимостью использовать первый пример - разработать точную последовательность действий, которые должен выполнить компьютер, одно за другим, не смотря на высокоуровневые концепции, которые они выражают.

Замечать, когда концепт требует, чтобы его заменили на новое слово, должно стать второй природой программиста.

Абстракция перемещения по массиву

Обычные функции, какими мы их видели до сих пор, являются хорошим способом строить абстракции. Но иногда они не оправдывают ожиданий.

В предыдущей главе, этот тип for цикличностей встречался нам несколько раз:

var array = [1, 2, 3];
for (var i = 0; i < array.length; i++) {
var current = array[i];
console.log(current);
}

Он пытается сказать: "Выведите в консоль каждыЙ элемент массива". Но он использует круговой способ, который в ключает в себя переменную-счетчик i,  проверяет длину массива, и вводит дополнительную переменную, чтобы выбрать текущий элемент. Помимо того, что это выглядит уродливо, это оставляет много места для потенциальных ошибок. Мы можем случайно повторно использовать переменные i и current, и т.п.

Так что давайте попробуем абстрагировать ее в другую функцию. Можете придумать способ?

И так, достаточно легко написать функцию, которая будет идти по массиву и вызывать console.log для каждого элемента.

function logEach (array) {
for (var i = 0; i < array.length; i++)
  console.log(array[i];
}

Но что, если мы захотим сделать что-то еще, помимо вывода элементов в консоль? Поскольку "делать что-то" может быть выражено как функция и функции - просто значения, мы можемпереносить наше действие, как функционально езначение.

function forEach (array, action) {
  for (var i = 0; i < array.length; i++)
    action(array[i]);
}
forEach (["Wampeter", "Foma", "Granfallon"], console.log);
//> Wampeter
//> Foma
//> Granfallon

(В некоторых браузерах такой способ вызова функции console.log не сработает. Вы можете использовать alert вместо console.log, если пример не работает)

Часто вы не передаете предопределенную функцию в функцию forEach, а создаете значение функции внутри нее вместо этого.

var numbers = [1, 2, 3, 4, 5], sum = 0;
forEach(numbers, function(number) {
  sum += number;
});
console.log(sum);
//> 15

Этот пример очень похож на классическую цикличность for,  с телом, записанным в виде блока под ней. Тем не менее, здесь тело находится внутри значения функции, также как и внутри скобок вызова функции forEach. Поэтому она должна быть закрыта закрывающими фигурными скобками и закрываться обычными скобками.

Используя этот шаблон, мы можем указать название переменной для текущего элемента (число), вместо того, чтобы выбирать это значение из массива вручную.

На самом деле, нам не нужно писать функцию forEach самостоятельно. Она доступна, как стандартный метод для массивов. Поскольку массив уже предоставлен, как элемент над которым выполняется метод, функция forEach забирает только один требуемый параметр: функцию, которая должна быть выполнена с каждым элементом.

Чтобы продемонстрировать как это полезно, давайте вернемся к функции из прошлой главы. Она содержит две цикличности, которые прокручивают массив.

function gatherCorrelations(journal) {
  var phis = {};
  for (var entry = 0; entry < journal.length; entry++){
    var events = journal[entry].events;
    for (var i = 0; i < events.length; i++) {
      var event = events[i];
      if (!(event in phis))
        phis[event] = phi(tableFor(event, journal));
    }
  }
  return phis;
}

Использвание forEach сделает её немного короче и немного чище.

function gatherCorrelations(journal) {
  var phis = {};
  journal.forEach(function(entry){
    entry.events.forEach(function(event){
      if (!(event in phis))
        phis[event] = phi(tableFor(event, journal));
    });
  });
  return phis;
}

ВЫСОКОУРОВНЕВЫЕ ФУНКЦИИ

Функции, которые действую на основе других функций, либо забирая их как параметры, либо возвращая их, называются высокоуровневыми. Если вы уже приняли тот факт, что функции являются обычными значениями, нет ничего особенного в том факте, что такие функции существуют. Определение пришло из математики, где различия между функциями и другими функциями принимаются более серьезно.

Высокоуровневые функции позволяют нам делать абстрактными действия, а не только значения. Они выражаются несколькими формами. Например, вы можете создать функции, которые будут создавать новые функции.

function greaterThan (n){
  return function (m) {return m > n; };
}
var greaterThan10 = greaterThan(10);
console.log(greaterThan10(11));
// > true

Кроме того, вы можете создавать функции, которые изменяют другие функции.

function noisy(f) {
  return function (arg) {
    console.log("calling with", arg);
    var val = f(arg);
    console.log("calling with", arg, "-got", val);
    return val;
  };
}
noisy(Boolean)(0);
//> calling with 0
//> calling with 0 - got false

Вы даже можете написать функции, которые будут обеспечивать новые типы потоков команд.

function unless (test, then) {
  if (!test) then ();
}
function repeat (times, body) {
  for (var i = 0; i < times; i++) body (i);
}

repeat (3, function(n){
  unless (n % 2, function (){
    console.log(n, "is even");
  });
});
// > 0 is even
// > 2 is even

Лексические правила областей, которые мы обсуждали в Главе 3 работают нам на пользу, когда мы используем функции таким образом. В предыдущем примере, переменная n это параметр внешней функции. Так как внутренняя функция живет в среде внешней, она может использовать n. Тела таких внутренних функций могут использовать переменные вокруг себя. Они могут играть роль похожую на блоки {}, используемые в обычных цикличностях и условных выражениях. Важное различие заключается в том, что переменные, введенные внутри функций не оказываются в среде внешней функции. И обычно это хорошо.

ПЕРЕДАЧА ПАРАМЕТРОВ

Функция noisy определенная раньше, которая захватывает свой параметр в другую функцию, имеет серьезный недостаток.

function noisy (f) {
  return function (arg) {
    console.log("calling with", arg);
    var val = f(arg);
    console.log("called with", arg, "- got", val);
    return val;
  };
}

Если f забирает больше одного параметра, она принимает только один (первый) из них. Мы можем добавить несколько параметров во внутреннюю функцию (arg1, arg2, и т.д.) и передать их всех в f, но не понятно сколько будет достаточно. Это решение также лишит f информации  том каково количество аргументов (arguments.length). Так как мы всегда будем передавать одно и то же коичество параметров, она не будет знать сколько парметров ей изначально было передано.

Для таких случаев, JavaScript функции содержат метод apply. Вы передаете ему массив (или объект похожий на массив) параметров, и он вызовет функцию с этими параметрами.

function transparentWrapping {
  return function () {
    return f.apply(null, arguments);
  };
}

Эта функция бесполезна, но она показывает пример, который нам интересен - функция, которую она возвращает проводит все данные ей параметры, и только их, в функцию f. Она делает это благодаря тому, что она передает свой объект параметров в метод apply. Первый параметр, который мы передаем в apply, в данном случае null, используется для симулирования вызова метода. Мы вернемся к этому в следующей главе.

JSON

Высокоуровневые функции, которые каким-либо образом применяют функцию к элементам массива, широко используются в JavaScript. Метод forEach является самым примитивным примером такой функции. Существует ряд других вариантов, которые доступны в качестве методов для массивов. Чтобы познакомиться с ними, давайте поиграем с другим набором данных.

Несколько лет назад, кто-то покопался в куче архивов и собрал книгу с историей моей семьи (Havrbeke - означет Овсяный ручей).  Я открыл её в надежде найти пиратов, князей, и алхимиков... но книга в большинстве своем была наполнена фламандскими фермерами. К моей радости, я вытащил информацию о моих прямых предках и собрал их в читаемый компьютером формат.

Файл, который я собрал, выглядит приблизительно так:

[
  {"name": "Emma de Milliano", "sex": "f",
  "born": 1876, "died": 1956,
  "father": "Petrus de Milliano",
  "mother": "Sophia van Damme"},
  {"name": "Carolus Haverbeke", "sex": "m",
  "born": 1832, "died": 1905,
  "father": "Carel Haverbeke",
  "mother": "Maria van Brussel"},
  ... и так далее
]

Такой формат называется JSON (произносится как "Джейсон"), который расшифровывается как JavaScript Object Notation. Он широко используется, как хранилище данных и формат связи в Вебе.

JSON похож на то, как JavaScript записывает массивы и объекты, с некоторыми ограничениями. Все названия свойств должны быть окружены двойными кавычками, и только простые выражения данных разрешены - никаких вызовов функций, переменных, или чего бы то ни было , что включает в себя вычисление. Комментарии также не разрешены в JSON.

JavaScript дает нам функции, JSON.stringify и JSON.parse, которые конвертируют данные из этого и в этот формат. Первый забирает значение JavaScript и возвращает закодированную в JSON текстовую строку. Второй забирает такую текстовую строку и конвертирует ее в значение, которое оно содержит.

var string = JSON.stringify({name: "X", born: 1980});
console.log(string);
//> {"name": "X", "born": 1980}
console.log(JSON.parse(string).born);
//> 1980

Перменная ANCESTRY_FILE, доступная в "песочнице" для этой главы и в виде скачиваемого файла на сайте, содержит данные моего файла JSON, в виде текстовой строки. Давайте декодируем его и посмотрим сколько людей он содержит.

var ancestry = JSON.parse(ANCESTRY_FILE);
console.log(ancestry.length);
//> 39

ФИЛЬТРАЦИЯ МАССИВА

Следующая функция может пригодиться, чтобы найти людей в генеологическом файле, который были молодыми в 1924 году. Она фильтрует элементы в массиве, которые не проходят тест.

function filter (array, test) {
  var passed = [];
  for (var i = 0; i < array.length; i++){
    if (test(array[i]))
      passed.push(array[i]);
  }
  return passed;
}
console.log (filter(ancestry, function(person){
  return person.born > 1900 && person.born < 1925;
}));
//> [{name: "Philibert Haverbeke", ...}, ...]

Этот пример использует параметр test, значение функции, чтобы заполнить "пространство" в вычислении. Функция test вызывается для каждого элемента, и ее возвращаемое значение определяет включен ли элемент в возвращаемый массив.

Трое людей были живы и молоды в 1924 году: мой прадед, прабабушка и пратётя.

Заметьте, как функция filter, вместо того, чтобы удалять элементы из существующего массива, строит новый массив, в котором остаются только те элементы, которые проходят тест. Это чистая функция. Она не модифицирует массив, который ей дан.

Как и forEach, filter является стандартным методом воздействия на массивы. На примере функция определена для того, чтобы показать, что она делает внутри. С этого момента, мы будем использовать ее так вместо этого:

console.log(ancestry.filter(function(person){
  return person.father == "Carel Haverbeke"
}));
//> [{name: "Carolus Haverbeke", ...}]

ТРАНСФОРМАЦИЯ С ПОМОЩЬЮ MAP

Допустим, у нас есть массив объектов, представляющих людей, который получился с помощью некой фильтрации массива ancestry. Но нам нужен массив имен, который легче читать.

Метод map трансформирует массив, применяя функцию ко всем его элементам и создает новый массив из возвращенных значений. Новый массив будет иметь такую же длину как и изначальный массив, но его содержимое будет "отформатировано" в новом виде с помощью функции.

function map(array, transform) {
  var mapped = [];
  for (var i = 0; i < array.length; i++)
    mapped.push(transform(array[i]));
  return mapped;
}

var overNinety = ancestry.filter(function(person){
  return person.died - person.born > 90;
});
console.log(map(overNinety, function(person){
return person.name;
}));
//> ["Clara Aernoudts", "Emile Haverbeke", "Maria Haverbeke"]

Интересно, что люди, которые дожили как минимум до 90 лет, те самые три человека, которых мы видели ранее, молодыми в 1920-х, и они из самого недавнего поколения в моем наборе данных. Полагаю, что медицина хорошо продвинулась.

Как forEach и filter, map также является стандартным методом воздействия на массивы.

РЕЗЮМИРУЕМ МЕТОДОМ REDUCE

Другим часто встречающимся примером вычислений с массивами, является вычленение единственного значения из них. Наш пример с повторением, суммирующий набор чисел, является примером такого вычесления. Другой пример покажет, как найти человека с самым ранним годом рождения в массиве данных.

Высокоуровневый процесс, который представляет этот пример носит название reduce (или иногда fold). Можете представить его, как складывание массива, под одному элементу за раз. Когда суммируются числа, вы начнете с числа 0 и, для каждого элемента, сложите его с текущей суммой, добавив два.

Параметры функции reduce, помимо массива, функция сложения и начальное значение. Эта функция менее очевидная, чем filter и map, поэтому стоит более внимательно ее рассмотреть.

function reduce (array, combine, start) {
  var current = start;
  for (var i = 0; i < array.length; i++)
    current = combine(current, array[i]);
  return current;
}

console.log(reduce([1, 2, 3, 4], function(a, b){
  return a+b;
}, 0));
//> 10

Стандартный метод манипуляции над массивом reduce, который конечно же относится к этой функции, имеет дополнительное удобство. Если твой массив содержит по крайней мере один элемент, ты можешь отбросить параметр start. Этот метод будет забирать первый элемент массива как начальное значение и начнет сокращать массив со второго элемента.

Использовать reduce для поиска моего самого древнего предка, можно так:

console.log(ancestry.reduce(function(min, cur){
  if (cur.born < min.born) return cur;
  else return min;
}));
//> {name: "pauwels van Haverbeke", born: 1535, ...}

КОМПОНУЕМОСТЬ

Представьте, как бы мы написали предыдущий пример (поиск самого древнего предка) без использования высокоуровневой функции. Код будет не на много хуже.

var min = anceestry[0];
for (var i = 1; i < ancestry.length; i++){
  var cur = ancestry[i]
  if (cur.born < min.born)
  min = cur;
}
console.log(min);
//> {name: "pauwels van Haverbeke", born: 1535, ...}

Тут на две переменные больше, и программа на две строки длиннее, но в ней всё еще достаточно просто разобраться.

Высокоуровневые функции начинают сиять, когда нам нужно компоновать функции. В качестве примера, давайте напишем код, который находит средний возраст мужчин и женщин в наборе данных.

function average (array) {
  function plus(a,b) { return a + b;}
  return array.reduce(plus) / array.length
}
function age(p) {return p.died - p.born;}
function male(p) {return p.sex == "m";}
function female(p) {return p.sex == "f";}
console.log(average(ancestry.filter(male).map(age)));
// > 61.67
console.log(average(ancestry.filter(female).map(age)));
// > 54.56

(Достаточно глупо, что нам приходится определять плюс в качестве функции, но операторы в JavaScript, в отличие от функций не являются значениями, поэтому их нельзя передавать в качестве параметров).

Вместо того, чтобы смешивать логику в большую цикличность, ее легче скомпоновать с помощью интересующих нас концептов - определение пола, расчета возраста, и выявленее среднего значения. Мы можем применить их один за другим и получить нужный нам результат.

Это великолепно подходит для написания чистого кода. К сожалению, эта четкость не достается бесплатно.

СТОИМОСТЬ

В счастливой стране элегантного кода и красивых радуг, живет монстр-кайфоломщик под названием неэффективность.

Программа, которая преобразует массив наиболее элегантно выражается последовательностью четко разделенных шагов, каждый из которых манипулирует с массивом и производит новый массив. Но строить все эти промежуточные массивы достаточно дорого.

Например, передавать функцию в forEach и позволять этому методу заботиться об итерациях с массивом для нас удобно и просто читать. Но вызовы функций в JavaScript обходятся дороже, чем простые цикличности.

То же самое можно сказать и об остальных техниках, которые улучшают читаемость программы. Абстракции накладывают слои между сырыми вещами, которые делает компьютер и концептами с которыми мы работаем, таким образом заставляя машину делать больше работы. Это не железный закон - есть языки программирования, которые лучше поддерживают строительство абстракций без добавления неэффективностей, и даже в JavaScript, опытный программист может найти способ написать быстрый абстрактный код. Но это проблема, которая возникает часто.

К счастью, многие компьютеры невероятно быстры. Если вы перерабатываете скромное количество данных или делаете что-то, что должно случиться только в измеримых человеком временных рамках (например, каждый раз когда пользователь нажимает на кнопку), тогда это не важно написал ли ты красивое решение, которое обрабатывается половину милисекунды или супероптимизированное решение, которое обрабатывается за десятую милесекунды.

Полезно грубо следить за тем как часто будет использоваться твоя программа. Если у тебя есть цикличность внутри цикличности (либо напрямую, либо по средством внешней цикличности, которая вызывает функцию, которая заканчивается выполнением внутренней цикличности), код внутри внутренней цикличности будет воспроизводиться NxM раз, где N - количество раз, которое повтояется внешней цикличностью и M - количество раз, которое выполняется внутренней цикличностью внутри каждой итерации внешней цикличности. Если эта внутренняя цикличность содержит другую цикличность, которая совершает P кругов, её тело будет воспроизводиться MxNxP раз, и так далее. Это может вылиться в огромное количество, и когда программа работает медленно, проблема часто может быть прослежена в маленькой части кода, которая сидит внутри внутренней цикличности.

ПРА-ПРА-ПРА-ПРА-...

Мой прадед, Филберт Хавербеке включен в файл с данными. Начиная с него, я могу проследить свою родословную, чтобы выяснить, является ли самый древний предок из набора данных, Пауэлс ван Хавербеке, моим прямым предком. И если является, хотелось бы знать какую часть ДНК я от него унаследовал.

Чтобы иметь возможность перейти от имени родителя к настоящему объекту, который представляет этого человека, мы сначала построим объект, который ассоциирует имена с людьми.

var byName = {};
ancestry.forEach(function(person){
  byName[person.name] = person;
});
console.log(byName["Philbert Haverbeke"]);
// > {name: "Philbert Haverbeke", ...}

Теперь проблема не совсем так проста, как просмотр свойств father и подсчет того, сколько потребуется, чтобы достичь Пауэлса. Есть несколько случаев в древе, когда люди женились на своих троюрдных кузинах (крошечные деревни и всё такое). Из-за этого ветви семейного древа воссоединяются в некоторых местах, что означает у меня больше чем 1/2G генов с этим человеком, где G это количество поколений между мной и Пуэлсом. Эта формула происходит из идеи, что каждое поколение делит пул генов на 2.

Разумным способом взглянуть на эту проблему будет посмотреть на нее как на аналог reduce, который сжимает массив в единственное значение, повторяющимся образом сочетая значения слева на право. В данном случае, мы также хотим сжать нашу структуру данных в единственное значение, но применимо к семейным линиям. Формат данных в данном случае будет скорее похож на дерево, нежели на плоский лист.

Способ, которым мы хотим сократить эту форму, заключается в вычислении значения конкретного человека, сочетая значения их предков. Этого можно добиться рекурсией: если мы интересуемся информацией по человеку А, мы должны вычислить значения родителей А, что в свою очередь требует вычисления значений дедушек и бабушек А, и так далее. В принципе, это может потребовать от нас вычислений бесконечного количества людей, но так как наш набор данных имеет ограничения, мы должны где-то остановиться. Таким образом, мы определим значение по умолчанию в нашей функции сокращения, которое будет относиться к людям за пределами нашего набора данных. В нашем случае, это значение - 0, основанное на предположении, что люди вне данных, не делят ДНК с предком, которого мы изучаем.

Получив человека, функция сочетающая значения двух родителей данного человека и значение по умолчанию, reduceAncestors  сжимает значение из семейного древа.

function reduceAncestors (person, f, defualtValue) {
  function valueFor(person) {
    if (person == null) {
      return defaultValue
    }else {
      return f(person, valueFor(byName[person.mother]),
                       valueFor(byName[person.father]));
    }
  }
  return valueFor(person);
}

Внутренняя функция valueFor обрабатывает одного человека. С помощью магии рекурсии, она может с легкостью вызывать саму себя, делая вычисления по отцу и матери заданного человека. Результаты, вместе с объектом самого человека, передаются в f, которая возвращает текущее значение по данному человеку.

Затем мы модем использовать результаты для вычисления количества ДНК моего прадеда свзяанного с Пауэлсом ван Хавербеке и разделить на 4.

function sharedDNA (person, fromMother, fromFather) {
  if(person.name == "Pauwels van Haverbeke")
    return 1;
  else
    return (fromMother+fromFather)/2;
}
var ph = byName["Philibert Hvarbeke"];
console.log(reduceAncestors(ph, sharedDNA, 0)/4);
//> 0.00049

Человек по имени Пауэлс ван Хавербеке очевидно делит 100% ДНК с Пауэлсом ван Хавербеке (в нашем наборе данных имена не повторяются) , таким образом функция возвращает 1 для него. Все остальные люди разделяют среднее количество ДНК, которое делят их родители.

Итак, говоря на языке статистики, я разделяю приблизительно 0.05% ДНК с этим человеком из 16 века. Следует заметить, что это лишь статистически приблизительное число, а не точное значение. Это достаточно маленькое число, но учитывая сколько генетического материала мы с собой несем (около 3 милиардов пар оснований), возможно еще существует некий аспект моей биологической машины, который унаследован от Пауэлса.

Мы могли бы также найти это значение не прибегая к функции reduceAncestors. Но разделение общего подходa (сжимания семейного древа) c с частным случаем (вычисление разделяемого ДНК) помогает улучшить ясность кода и позволяет нам переиспользовать абстрактную часть программы для в других случаях. Например, следующий код находит процент известных предков человека, которые прожили больше 700 лет (линейным способом, когда люди могут быть посчитаны несколько раз):

function countAncestors(person, test) {
  function combine (current, fromMother, fromFather){
    var thisOneCounts = current != person && test(current);
    return fromMother + fromFather + (thisOneCounts ? 1 : 0);
  }
  return reduceAncestors(person, combine, 0);
}
function longLivingPercentage (person) {
  var all = countAncestors(pesron, function(person){
  return true;
  });
  var longLiving = countAncestors(person, function(person){
    return (person.died - person.born) >= 70;
  });
  return = longLiving / all;
}
console.log(longLivingPercentage(byName["Emile Haverbeke"]));
//> 0.129

Такие числа не стоит воспринимать всерьез, учитывая что наш набор данных содержит достаточно произвольный набор людей. Но код иллюстрирует тот факт, что reduceAncestors дает нам полезный кусок словаря, с помощью которого можно обрабатывать структуру данных семейного древа.

ПРИСОЕДИНЕНИЕ

Метод bind, который содержится во всех функциях, создает новую функцию, которая будет вызывать оригинальную функцию но с уже заданными параметрами.

Следующий пример кода показывает метод bind в действии. Он определяет функцию isInSet, которая указывает упоминается ли человек в данном наборе текстовых строк. Чтобы вызвать filter для сбора объктов людей, чьи имена присутствуют в заданном наборе,  мы можем либо написать выражение функции, которое вызывает isInSet с нашим набором в качестве первого параметра или частично применить функцию isInSet.

var theSet = ["Carel Haverbeke", "Maria van Brussel", "Donald Duck"];
function isInSet(set, person) {
  return set.indexOf(person.name) > -1;
}

console.log(ancestry.filter(function(person){
  return isInSet(theSet, person);
}));
//> [{name: "Maria van Brussel", ...},
     {name: "Carel Haverbeke", ...}]
console.log(ancestry.filter(isInSet.bind(null, theSet)));
//> ... same result

Вызов к функции bind возвращает функцию которая вызовет isInSet с переменной theSet как первый параметр, которая будет продолжена оставшимися параметрами, переданными связанной функции.

Первый параметр, там где на примере передается null, используется для вызова метода, похожего на первый параметр для apply. Я объясню это подробнее в следующей главе.

ЗАКЛЮЧЕНИЕ

Имея возможность передавать значения функций в другие функции это не просто пыль в глаза, а глубоко важный аспект JavaScript. Он позволяет писать вычисления с "пробелами" в качестве функций и иметь код, который вызывает эти функции, заполняя их пробелы, предоставляя значения функций, которые описывают отсутсвующие вычисления.

Массивы обеспечивают ряд полезных высокоуровневых методов - forEach, который делает что-то с каждым элементом в массиве. Filter строит новый массив с некоторыми отфильтрованными элементами. Map строит новый массив, где каждый элемент проходит через функцию, а reduce сочетает все элементы массива в единственное значение.

У функций есть метод apply, который можно использовать для вызова с массивом, уточняющим их параметры. У них также есть метод bind, который используется для создания частично примененной версии функции.

ГЛАВА 6
Секретная жизнь объектов

"Проблема объектно-ориентированных языков программирования состоит в том, что они тянут за собой все свое неявное окружение. Ты хотел получить банан, а получил гориллу с бананом в руке и целые джунгли".

- Джо Армстронг, из интервью "Coders at Work"

Когда программист говорит слово "объект", оно несет в себе большую смысловую нагрузку. В моей профессии, объекты являются видом жизни, предметом священных войн, и любимое ключевое слово, которое все еще не утратило своей силы.

Для постороннего человека это может звучать странно. Давайте начнем с короткой истории объектов в программировании.

ИСТОРИЯ

Эта история, как и многие истории в программировании, начинается с проблемы сложности. Одна философия заключается в том, что сложностью можно управлять разделяя ее на маленькие части, которые изолированы друг от друга. Эти части стали называть объектами.

Объект это твердая оболочка, которая прячет липкую сложность внутри себя и взамен предлагает несколько ручек и связок (таких как методы), которые представляют интерфейс, через который можно пользоваться объектом. Идея состоит в том, что интерфейс относительно простой и все сложные вещи, которые происходят внутри объекта, можно игнорировать, работая с ним.

В качестве примера, можете представить объект, который обеспечивает интерфейс области вашего экрана. Он позволяет нарисовать фигуры и текст внутри этой области, но скрывает все детали того, как эти формы конвертируются в пиксели, которые составляют экран. У вас был бы набор методов - например, drawCircle - и они будут единственными вещами, которые нужно знать, чтобы пользоваться таким объектом.

Эти идеи были изначально разработаны в 70-х и 80-х годах, а в 90-х распространены огромной волной обмана - революцией объектно-ориентированного программирования. Внезапно, появилось целое большое племя людей, которые утверждали, что объекты являются единственно правильным способом программировать - и все, что не использует объекты является устаревшим нонсенсом.

Такой вид фанатизма обычно производит множество непрактичной глупости, что вызвало в некотором роде контрк-революцию. В некоторых кругах сегодня, объекты имеют очень плохую репутацию.

Я предпочитаю смотреть на проблему с практичной, а не идеалогичной, стороны. Есть несколько полезных концепций, в основном "герметизация" (разделение между внутренней концепцией и внешним интерфейсом), которую популяризировала объектно-ориентированная культура. Их имеет смысл изучать.

Эта глава описывает достаточно эксцентричный подход JavaScript к объектам, и к тому, как они относятся к некоторым классическим объектно-оринетированным техникам.

МЕТОДЫ

Методы - это просто свойства, которые содержат в себе значения функций. Вот пример простого метода:

var rabbit = {};
rabbit.speak = function(line) {
  console.log("The rabbit says '"+ line + "");
};

rabbit.speak("I'm alive.");
// -> The rabbit says 'I'm alive.'

Обычно методу нужно что-то сделать с объектом, который вызвал его. Когда функция вызывается в виде метода - просматривается как свойство и сразу же вызывается, как в случае с object.method() - специальная переменная this в его теле будет указывать на объект которым она вызвана.

function speak(line) {
  console.log("The " + this.type + " rabit says '" + line + "'");
}

var whiteRabbit = {type: "white", speak: speak};
var fatRabbit = {type: "fat", speak: speak};

whiteRabbit.speak("Oh my ears and whiskers, " + "how late it's getting!");

//-> The white rabbit says 'Oh my ears and whiskers, how late it's getting!'
fatRabbit.speak("I could sure use a carrot right now.");
//-> The fat rabbit says "I could sure use a carrot right now."

Код использует ключевое слово this чтобы вывести тип кролика, который говорит. Вспомните, что методы apply и bind оба берут первый параметр, который можно использовать, чтобы просимулировать вызов метода. Первый параметр по сути используется, чтобы дать значение this.

Есть похожий на apply метод call. Он также вызывает функцию, методом которой он является, но забирает параметры нормально, а не в виде массива. Как apply и bind, call можно передать специфичное значение this.

speak.apply(fatRabbit, ["Burp!"]);
// -> The fat rabbit says 'Burp!'
speak.call({type: "old"}, "Oh my.");
// -> The old rabbit says 'Oh my.'

ПРОТОТИПЫ

Смотрите внимательно.

var empty = {};
console.log(empty.toString);
// -> function toString(){…}

Я только что вытащил свойство из пустого объекта. Магия!

Ну не совсем. Я просто умалчивал информацию о том, как работают объекты JavaScript. В дополнение к набору свойств, почти все объекты имеют прототип. Прототип это еще один объект, который используется как резервный источник свойств. Когда объект получает запрос на свойство, которого у него нет, его прототип будет обыскан на предмет налличия свойств, затем прототип прототипа, и так далее.

Так что же является прототипом этого пустого объекта? Это великий предок прототипов, достояние почти всех объектов, Object.prototype.

console.log(Object.getPrototypeOf({}) == Object.prototype);
//> true
console.log(Object.getPrototypeOf(Object.prototype));
//> null

Как вы должно быть ожидали, функция Object.getPrototypeOf возвращает прототип объекта.

Отношения прототипов в объектах JavaScript формируют древообразную структуру, и в корне этой структуры сидит Object.prototype. Он обеспечивает несколько методов, которые показываются во всех объектах, таких как toString, который конвертирует объект в текстовую строку.

Во многих объектах прототип Object.prototype содержится не напрямую, а вместо этого содержат другой объект, который обеспечивает собственные свойства по умолчанию. Функции происходят от Function.prototype, а массивы происходят из Array.prototype.

console.log(Object.getPrototypeOf(isNan) == Function.prototype);
//> true
console.log(Object.getPrototypeOf([]) == Array.prototype);
//> true

Такой прототипный объект сам будет содержать прототип, часто Object.prototype, таким образом он будет не напрямую обеспечивать методы типа toString.

Функция Object.getPrototypeOf очевидно возвращает прототип объекта. Вы можете использовать Object.create для того, чтобы создать объект со специфичным прототипом.

var protoRabbit = {
  speak: function(line) {
    console.log("The "+this.type + " rabbit says '" + line + "'");
  }
};
var killerRabbit = Object.create(protoRabbit);
killerRabbit.type = "killer";
killerRabbit.speak("SKREEEE! ")
/> The killer rabbit says 'SKREEEE!'

"Proto" кролик действует как контейнер для свойств, которыми располагают все кролики. Каждый объект кролик, как убица кролик, содержит в себе свойства, которые применимы только к нему - в данном случае его тип, и наследует общие свойства из своего прототипа.

КОНСТРУКТОРЫ

Более удобным способом создавать объекты, которые происходят из какого-либо общего прототипа, является создание конструктора. В JS вызов функции с ключевым словом new в начале говорит о том, что к ней нужно относиться как к конструктору. Конструктор будет иметь переменную this привязанную к свежему объекту, и до тех пор пока он точно возвращает значение другого объекта, этот новый объект будет возвращен вызовом.

Объект созданный с ключевым словом new называется состоянием этого конструктора.

Вот простой конструктор для кроликов. Существует общая практика писать имена конструкторов с большой буквы, так чтобы их можно было с легкостью отличить от других функций.

function Rabbit(type) {
  this.type = type;
}

var killerRabbit = new Rabbit("killer");
var blackRabbit = new Rabbit("black");
console.log(blackRabbit.type);
//> black

Конструкторы (на самом деле, все функции) автоматически получают свойство под названием prototype, которое по умолчанию содержит простой, пустой объект, который происходит от Object.prototype. Каждое состояние созданное этим конструктором будет иметь этот объект в качестве прототипа. Так, чтобы добавить метод speak к кроликам, созданных с помощью конструктора Rabbit, мы можем просто сделать следующее:

Rabbit.prototype.speak = function(line) {
console.log("The " + this.type + " rabbit says '" + line + "'");
  }
blackRabbit.speak("Doom...");
//> The black rabbit says 'Doom...'

Важно отметить различие между тем, как прототип ассоциируется с конструктором (с помощью своего свойства prototype) и тем, как у объектов есть прототип (который можно извлечь с помощью Object.getPrototypeOf). Текущим прототипом конструктора является Function.prototype, так как конструкторы являются функциями.  Его свойство prototype будет прототипом состояний созданных через него, но не его собственный прототип.

ПЕРЕЗАПИСЬ УНАСЛЕДОВАННЫХ СВОЙСТВ

Когда вы добавляете свойство объекту, вне зависимости от того, есть ли оно в прототипе или нет, свойство добавляется к самому объекту, и в последствии будет его собственным свойством. Если в прототипе есть свойство с идентичным названием, это свойство больше не будет влиять на объект. Сам прототип не меняется.

Rabbit.prototype.teeth = "small";
console.log(killerRabbit.teeth);
//> small
killerRabbit.teeth = "long, sharp and bloody";
console.log(killerRabbit.teeth);
//> long, sharp and bloody
console.log(blackRabbit.teeth);
//> small
console.log(Rabbit.prototype.teeth);
//> small

Следующая диаграма показывает ситуацию после того, как код был воспроизведен. Прототипы Rabbit и Object находятся за killerRabbit как своего рода фон, где можно посмотреть свойства, которые не найдены в самом объекте.

Перезапись свойств, которая существует в прототипе, полезное действие. Как показывает пример с зубами кролика, его можно использовать для выражения свойств исключений в состояниях более общего класса объектов, позволяя обычным объектом без исключений просто перенимать стандартное значение прототипа.

Перезапись также используется для того, чтобы дать стандартным прототипам функции и массива метод toString, отличающийся от базового прототипа объекта.

console.log(Array.prototype.toString == Object.prototype.toString);
//> false
console.log([1,2].toString());
//> 1,2

Вызов функции toString применимо к массиву дает результат похожий на вызов .join(",") к нему же. Он ставит запятыне между значениями массива. Напрямую вызывая Object.prototype.toString с массивом, получается другая текстовая строка. Эта функция не знает о массивах, так что она просто выводит слово "объект" и название типа между квадратными скобками.

console.log(Object.prototype.toString.call([1,2]));
//> [object Array]

ВМЕШАТЕЛЬСТВО ПРОТОТИПОВ

Прототип можно использовать в любое время, чтобы добавить новые свойства и методы для всех объектов, которые основаны на нем. Например, может возникнуть необходимость научить танцевать всех наших кроликов.

Rabbit.prototype.dance = function(){
  console.log("The " + this.type + " rabbit dances a jig.");
}
killerRabbit.dance();
//> The killer rabbit dances a jig.

Это удобно. Но есть ситуации, когда это наносит вред. В предыдущих главах, мы использовали объект как способ ассоциировать значения с названиями, создавая свойства для названий, задавая им соответствующие значения в качестве их значений. Вот пример из Главы 4:

var map = {};
function storePhi(event, phi) {
map[event] = phi;
}
storePhi("pizza", 0.69);
storePhi("touched tree", -0.081);

Мы можем пройтись по всем значениям phi в объекте с помощью for/in цикличности и протестировать есть ли там название, используя обычный оператор in. Но, к сожалению, прототип объекта встает на пути.

Object.prototype.nonsense = "hi";
for (var name in map);
console.log(name);
//> pizza
//> touched tree
//> nonsense
console.log("nonsense" in map);
//> true
console.log("toString" in map);
//> true

// Удалим проблематичное свойство опять
delete Object.prototype.nonsense

Всё это неправильно. Нету никакого события под названием "nonsense" в нашем наборе данных. И в нем определенно нет события под названием "toString".

Странно, toString ведь не показался в цикличности for/in, хотя оператор in вернул true для него. Это потому, что JS различает перечисляемые и неперечисляемые свойства.

Все свойства, которые мы создаем просто назначая их, являются перечисляемыми. Стандартные свойства объекта а Object.prototype  все являются неперечисляемыми, поэтому они не выводятся при такой цикличности for/in.

Есть возможность определить наши собственные неперечисляемые свойства, используя функцию Object.defineProperty, которая позволяет нам контролировать тип свойства, которое мы создаем.

Object.defineProperty (Object.prototype, "hiddenNonsense", {enumerable: false, value: "hi"} );
for (var name in map)
  console.log(name);
// > pizza
// > touched tree
console.log(map.hiddenNonsense);
//> hi

Теперь свойство в объекте, но оно не показывается в цикличности. Это хорошо. Но у нас все еще проблема с обычным оператором in, который утверждает, что свойства Object.prototype существуют в нашем объекте. Для этого мы можем использовать метод объект hasOwnProperty.

console.log(map.hasOwnProperty("toString"));
//> false

Этот метод говорит нам о том, есть ли у самого объекта это свойство, без просмотра его прототипов. Это часто более важная информация, чем та, то предоставляет оператор in.

Если вы беспокоитесь о том, что кто-то (какой-то другой код, задействованный в вашу программу) воздействовал на базовый прототип объекта, я советую вам писать ваши цикличности for/in в таком виде:

for (var namу in map) {
  if (map.hasOwnProperty(name)) {
  // ... this is an own property
  }
}

ОБЪЕКТЫ БЕЗ ПРОТОТИПА

Но кроличья нора на этом не заканчивается. Что если кто-то завел название hasOwnProperty в вашем map объекте и установил его значение на 42? Тогда вызов map.hasOwnProperty будет пытаться вызвать локальное свойство, которое содержит значение, а не функцию.

В таком случае, прототипы мешают, и мы бы предпочли объекты без прототипов. Мы видели функцию Object.create, которая позволяет создавать объект со специальным прототипом. Вы можете передавать значение null как прототип, чтобы создать свежий объект без прототипа. Для таких объектов как map, где свойства могут быть чем угодно, это прямо то, что нам нужно.

var map = Object.create(null);
map["pizza"] = 0.069;
console.log("toString" in map);
//> false
console.log("pizza" in map);
//> true

Намного лучше! Нам больше не нужна неуклюжая проверка hasOwnProperty, потому что все свойства объекта являются его собственными. Теперь мы можем безопасно использовать for/in цикличности вне зависимости от того, как люди манипулируют объектом Object.prototype.

ПОЛИМОРФИЗМ

Когда вы вызываете функцию String, которая конвертирует значение в текстовую строку, применимо к объекту, она вызовет метод toString на этот объект, чтобы попробовать создать значимую текстовую строку для возврата. Я упоминал, что некоторые стандартные прототипы определяют свою собственную версию toString, так что они могут создать текстовую строку, которая содержит более полезную информацию, чем "[object Object]".

Это простое состояние мощной идеи. Когда кусок кода написан для того, чтобы работать с объектами, с определенным интерфейсом, в данном случае, с методом toString - любой тип объекта, который поддерживает этот интерфейс может быть вставлен в код, и он будет просто работать.

Эта техника называется полиморфизмом - хотя никакого действительного изменения формы не происходит. Полиморфный код может работать зо значениями разных форм, до тех пор пока они поддерживают  ожидаемый интерфейс.

РАСКЛАДКА ТАБЛИЦЫ

Я собираюсь пройтись по более приближенному примеру в попытке лучше показать как выглядит полиморфизм и объектно-оринтированное программирование в целом. Проект такой: мы напишем программу, с заданным массивом массивов ячеек таблицы, которая строит текстовую строку, содержащую отлично разложенную таблицу - что значит - колонки прямые и ряды разлинованны. Что-то типа этого:

name         height country
------------ ------ -------------
Kilimanjaro    5895 Tanzania
Everest        8848 Nepal
Mount Fuji     3776 Japan
Mont Blanc     4808 Italy/France
Vaalserberg     323 Netherlands
Denaldi        6168 United States
Popocatepetl   5465 Mexico

Наша строящая таблицы система будет работать таким образом, что строящая функция будет спрашивать каждую ячейку как широко и высоко она хочет быть и затем использовать информацию, чтобы определить ширину колонок и высоту рядов. Строящая функция затем будет просить ячейки быть нарисованными в правильном размере и собирать результат в единую текстовую строку.

Программа раскладка будет общаться с объектами ячеек через определенный интерфейс. Таким образом, типы ячеек, которые поддерживает программа, не ограничены заранее. Мы можем добавить новые стили ячеек позже, например - подчеркнутые ячейки для табличных заголовков - и если они поддерживают наш интерфейс они будут работать, не запрашивая изменений в раскладке программы.

Вот интерфейс:

- minHeight() возвращает число указывающее на минимальную высоту, которое требуется этой ячейке (в строках).
- minWidth() возвращает число указывающее минимальную ширину этой колонки (в знаках).
- draw(width, height) возвращает масив длины height, который содержт список текстовых строк, каждая из которых шириной количества символов width. Представляет собой содержимое ячейки.

Я собираюсь серьезно использовать высокоуровневые методы с массивами в этом примере, так как это хорошо сочетается с этим подходом.

Первая часть программы вычисляет массивы минимальных значений ширины колонки и высоты ряда для разлиновки ячеек. Переменная rows будет содержать массив массивов, с каждым внутренним массивом представляющим собой ряд ячеек.

function rowHeights(rows) {
  return rows.map(function(row) {
    return row.reduce(function (max, cell){
      return Math.max(max, cell.minHeight());
    })
  })
}

function colWidth(rows) {
  return rows[0].map(function(_, i) {
    return rows.reduce(function(max, row) {
      return Math.max(max, row[i].minWidth());
    },0);
  })
}

Использование имени переменной начинающегося с нижнего подчеркивания (_) или состоящего полностью из единого подчеркивания, способ указать (читающим людям) на то, что этот параметр не будет использоваться.

Функцию rowHeights не должно быть сложно разобрать. Она использует функцию reduce, чтобы вычислить максимальную высоту массива ячеек и оборачивает ее в функцию map для того, чтобы сделать то же самое с рядами массива.

С функцией colWidth немного сложнее, потому что внешний массив является массивом рядов, а не колонок. Я еще не говорил о том, что функция map (как и forEach, filter и похожие методы для массивов) передает второй параметр функции, которой она передается: позицию текущего элемента. Прокручивая элементы первого ряда и всего лишь используя второй параметр прокручивающей функции, функция colWidth строит массив с одним элементом для каждого порядкового номера колонки. Вызов reduce проходит через внешний массив rows по каждому порядковому номеру и выбирает ширину самой широкой ячейки этого порядкового номера.

Вот код, рисующий таблицу:

function drawTable(rows) {
  var heights = rowHeights(rows);
  var widths = colWidth(rows)


  function drawLine(blocks, lineNo) {
    return blocks.map(function(block){
      return block[lineNo];
    }).join(" ");
  }

  function drawRow(row, rowNum) {
    var blocks = row.map(function(cell, colNum) {
      return cell.draw(widths[colNum], heights[rowNum]);
    });
    return blocks[0].map(function(_, lineNo){
      return drawLine(blocks, lineNo);
    }).join("\n");
  }
  return rows.map(drawRow).join("\n");
}

Функция drawTable использует внутреннюю функцию-помощника drawRow, чтобы нарисовать все ряды и затем соединяет их вместе с помощью знаков новая строка.

Функция drawRow сама по себе конвертирует объекты ячеек в ряду в "блоки", которые являются массивами строк, представляющих собой контент ячеек, разделенных линией. Единственная ячейка содержащая просто число 3776 могла бы быть представлена массивом из единственного элемента как ["3776"], тогда как подчеркнутая ячейка могла бы занимать две строки и быть представлена массивом ["name", "----"].

Блоки для ряда, которые все имеют одну высоту, должны появляться друг за другом в финальном виде. Второй вызов функции map в drawRow строит эти выводимые данные строчку за строчкой, проходя через строки в самом левом блоке и, для каждого из них, собирая линию, которая перекрывает полную ширину таблицы. Эти строки затем соединяются с помощью знаков новой строки, чтобы обеспечить целый ряд, как возвращаемое значение функции drawRow.

Функция drawLine вычленяет строки, которые должны появляться друг за другом, из массива блоков и соединяет их с помощью пробела, чтобы создать промежуток шириной в один символ между колонками таблицы.

Теперь давайте напишем конструктор для ячеек, который содержит текст, который применяет интерфейс для ячеек колонки. Конструктор делит текстовую строку на массив строк используя метод split, который разрезает текстовую строку при каждом встречном параметре, который для нее задан, и возвращает массив кусочков. Метод minWidth находит максимальную ширину в этом массиве.

function repeat (string, times) {
  var result = "";
  for (var i = 0; i < times; i++)
    result += string;
  return result;
}

function TextCell (text) {
  this.text = text.split("\n");
}

TextCell.prototype.minWidth = function() {
  return this.text.reduce(function(width, line) {
  return Math.max(width, line.length);
  }, 0);
};

TextCell.prototype.draw = function(width, height){
  var result = [];
  for (var i = 0; i < height; i++){
    var line = this.text[i] || "";
    result.push(line + repeat(" ", width - line.length));
  }
  return result;
};
