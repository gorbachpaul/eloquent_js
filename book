Высокоуровневые функции

"Цу-ли и Цу-зу хвастались размерами своих последних программ. "Двести тысяч строк", скзал Цу-ли, " не считая комментариев!" Цу-зу ответил, "Пф, моя уже насчитывает больше миллиона." Учитель Юан-Ма сказал: "Моя лучшая программа состоит из 500 строк". Услышав это, Цу-ли и Цу-зу просветились.
- Мастер Юан-Ма, Книга программирования

"Есть два способа разрабатывать программное обеспечение: делать его таким простым, что в нем очевидно не будет недостатков, или делать его таким сложным, что в нем не будет очевидных недостатков.

Большая программа - дорогая программа, и не только из-за времени, которое приходится тратить на ее создание. Размер почти всегда несет в себе сложность, а вводит в смятение программистов. Смущенные программисты, в свою очередь, чаще всего допускают баги (ошибки) в программах. Большая программа также создает много мест, где ошибки могут прятаться, из-за чего и становится сложно найти.

Давайте коротко вернемся к последним двум программам из введения. Первая - самодостаточная и содержить 6 строчек кода.

var total = 0, count = 1;
while (count<= 10) {
total += count;
count+= 1;
}
console.log (total);

Вторая основана на двух внешних функциях и состоит из одной строки.

console.log(sum(range(1, 10)));

В какой из них скорее всего может завестись баг?

Если мы посчитаем размер определений функций sum и range, вторая программа будет большой - даже больше первой. Однако, все равно, можно поспорить, что она скорее будет правильной.

Она скорее будет правильной, потому что решение описано в словаре, который соответствует решаемой проблеме. Суммируя диапазон чисел не о цикличности и счетчиках, или других незначительных деталях. Но из-за того, что они описаны более простыми концепциями, чем программа в целом, их легче правильно использовать.

Абстракция

В контексте программирования, эти типы словарей обычно называются абстракциями. Абстракции скрывают детали и дают нам способность говорить о проблемах на более высоком (абстрактном) уровне.

Как аналогия, сравните эти два рецепта горохового супа:

"Положите 1 чашку сухого гороха на человека в контейнер. Добавьте воды, чтобы она покрыла горох. Оставьте горох в воде на 12 часов. Вытащите гороз из воды и положите его на сковородку. Добавьте четыре чашки воды на человека. Накройте сковородку и тушите горох в течение двух часов. Возьмите половины луковицы на человека. Разрежьте ножом на части. Добавьте в горох. Возьмите стебель сельдерея на человека. Порежьте его ножом на части. Добавьте в горох. Возьмите морковку на человека. Порежьте на части. Ножом! Добавьте в горох. Готовьте еще 10 минут.

И второй рецепт:

"На человека: 1 чашка сухого гороха, половина порезанного лука, стебель сельдерея и морковь.

Замочите горох в течение 12 часов. Тушите в течение 2х часов в 4х чашках воды (на человека). Порежьте и добавьте овощи. Готовьте еще 10 минут.

Второй короче и легче интерпретировать. Но вам нужно понимать немного больше кулинарных терминов - замочите, потушите, порежьте, и возможно, овощи.

Программируя, мы не можем рассчитывать на то, что в словаре будут все слова, которые нам нужны. Таким образом, мы можем столкнуться с необходимостью использовать первый пример - разработать точную последовательность действий, которые должен выполнить компьютер, одно за другим, не смотря на высокоуровневые концепции, которые они выражают.

Замечать, когда концепт требует, чтобы его заменили на новое слово, должно стат второй природой программиста.

Абстракция перемещения по массиву

Обычные функции, какими мы их видели до сих пор, являются хорошим способом строить абстракции. Но иногда они не оправдывают ожиданий.

В предыдущей главе, этот тип for цикличностей встречался нам несколько раз:

var array = [1, 2, 3];
for (var i = 0; i < array.length; i++) {
var current = array[i];
console.log(current);
}

Он пытается сказать: "Выведите в консоль каждыЙ элемент массива". Но он использует круговой способ, который в ключает в себя переменную-счетчик i,  проверяет длину массива, и вводит дополнительную переменную, чтобы выбрать текущий элемент. Помимо того, что это выглядит уродливо, это оставляет много места для потенциальных ошибок. Мы можем случайно повторно использовать переменные i и current, и т.п.

Так что давайте попробуем абстрагировать ее в другую функцию. Можете придумать способ?

И так, достаточно легко написать функцию, которая будет идти по массиву и вызывать console.log для каждого элемента.

function logEach (array) {
for (var i = 0; i < array.length; i++)
  console.log(array[i];
}

Но что, если мы захотим сделать что-то еще, помимо вывода элементов в консоль? Поскольку "делать что-то" может быть выражено как функция и функции - просто значения, мы можемпереносить наше действие, как функционально езначение.

function forEach (array, action) {
  for (var i = 0; i < array.length; i++)
    action(array[i]);
}
forEach (["Wampeter", "Foma", "Granfallon"], console.log);
//> Wampeter
//> Foma
//> Granfallon




















































